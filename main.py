# Пайтон - ОО язык П.
# Т.е. все в пайтон есть объект.
# Объекты создаются на основании классов.
# У классов есть атрибуты.
# Если значение атрибута это функция, то атрибут называется методом. Метод = атрибут объекта, значением которого является функция.
# Метод это функция, которую можно вызывать на уровне класса.
# Каждая сущность в пайтон это объект.
# Основные типы (классы) объектов:
# 1. Строки. Это экземпляры класса строка. 'str'
# 2. Bool True
# 3. Целое число int 10
# 4. Список list [1, 2, 3] просто элементы
# 5. Словарь dict {'min':4, 'max':6}. Пара ключ-значение

# значение, которое пользователь вводит в функции input является строкой.

# Путем вызова функции dir можно получить все атрибуты объекта. Т.е. эта функция отобразит имена всех атрибутов объекта
# (переменной)
# name = 'Nik'
# print(dir(name)
# У строк есть ряд атрибутов, которые являются методами.
# Методы можно вызывать с помощью точки.
# print(name.upper())

# ctrl+shift+k удалить строку.

# print(dir(__builtins__)) - выводить все встроенные в пайтон функции.

# ctrl+shift+p, вводим format чтобы автоматическое форматирование произошло (коррекция кода)
# autopep8 я скачал.
# У меня стоят расширения autopep8, code runner, pylance, python для VScode.
# ctrl+, это настройки.

# Результатом выражения является всегда значение определенного типа.
# 5 + 3 (выражение) = 8 (результат выражения, сумма значений)
# a > b  # True или False
# 'hello' + 'World'  # "Hello World"
# my_func(10, 5)  # Результат функции. Можно использовать в вызове других функций, потому что вызов функции это выражение.


# Инструкции (statements). Создать функцию, запустить цикл. Инструкция выполняет действие.
# my_name = Nick  # Это инструкция по присвоению значения Nick переменной my_name с помощью оператора =

# if my_name:
#     print(my_name)  # Это условная инструкция.

# import datetime  # Это инструкция по импортированию модуля


# Переменные дают возможность повторного доступа к значениям, которые присвоены этим переменным.

# snake_case (переменные. функции, методы, модули)
# PascalCase (классы)
# my-package (пакеты, т.е. наборы модулей)
# DB_PASSWORD (константы, т.е. snake_case в верхнем регистре). Так-то значение этой переменной тоже можно изменить, но это сигнал
# для разработчиков будет, чтобы они видели.

# Пайтон - язык с динамической типизацией, т.е. одной и той же переменной можно присваивать разные значения.
# Тип переменной определяется типом присвоенного ей значения.

# В переменных использовать осмысленное имя существительное
# В функциях и методах использовать глаголы


# В пайтон отсутствуют примитивные типы данных, все является объектом.
# В пайтон существуют изменяемые и неизменяемые типы данных.
# Int - не изменяемый тип. Если мы переназначим значение переменной, то это будет другой объект просто (mutable)
# List () - изменяемый тип. Можно удалять объекты, добавлять, менять местами. Mutable objects (мутируемый)

# Неизменяемые типы: str, bool, int, float, tuple (кортеж), None (NoneType)
# Изменяемые типы: list (могут быть неуникальные объекты), dict, set(только уникальные объекты), пользовательские классы

# Переменные это просто ссылки на объекты, которые содержатся где-то в памяти.
# value = 10
# print(id(value))  # с помощью функции id можно получить место хранения объекта в памяти.
# Можно создать несколько переменных и привязать к ним один объект, эти переменные будут просто ссылками.

# alt+shift+вниз это скопировать строку
# alt+вверх или вниз это перемещать строку.
# ctrl+d выделить название

# value = 10
# print(type(value))  # С помощью функции type можно узнать класс объекта

# info = '''You are
# using cool
# language'''  # с помощью тройных кавычек можно многострочный объект класса str написать.

# print(info)


# my_name = 'Nickolay'
# print(len(my_name))

# print(my_name[0])

# print(my_name[2:5])


# Наиболее частые методы строк upper, replace, count, lower, index, capitalize.
# Если мы создаем объект класса строки, он наследует методы класса строки.

# my_comment = 'This is my long comment'

# print(my_comment.replace('long', 'short'))  # метод replace заменяет элементы в строке. Строка это не изменяемый объект.
# Методы строки
# не могут создавать новый объект. Если мы потом вызовем print(my_comment), то вернется строка в первоначальном виде.

# Integer
# user_input = input('Print any number: ')
# any_num = int(user_input)  # С помощью int() можно изменить тип данных с str на int

# print(type(any_num))


# user_input = int(input('Print any number: '))  # Или можно так сразу сделать
# # any_num = int(user_input)

# print(type(user_input))

# Возведение в степень.
# base = 5
# power = 3

# print(pow(base, power))

# # Или можно использовать оператор **
# print(5 ** 3)

# Можно большие числа разделять знаком _ для читаемости
# million = 1_000_000

# print(million)


# Чтобы курсор в двух местах поставить, надо нажать альт и щелкнуть в другое место.


# Float. Можно делать конвертацию float в int и str, str в float.
# q_ty = 17.25
# print(round(q_ty))  # Вот так можно округлять в большую сторону.


# 36. Комплексные числа. Состоят из действительной и мнимой части. Это объекты класса complex.
# complex_a = 3 + 5j (3 действительная часть, 5 мнимая часть).

# complex_a = 7 + 8j
# complex_b = 3 + 11j
# sum = complex_a + complex_b

# print(sum)

# print(type(sum))

# # sum = (7 + 8j)(3 + 11j) = 7*3 + 7*11j + 8j*3 + 8j*11j = 21 + 77j + 24j + 88j^ = 21 + 77j + 24j - 88 = -67 + 101j  # т.е.
# 88j в квадрате это просто -88


# 37. Bool часто используется в при проверке правдивости выражения (в сравнениях)
# Можно делать конвертацию любого значения в bool.


# 39. Пайтон не выполняет неявную конвертацию типов.
# Встроенные функции для явной конвертации типов: str(), float(), tuple, int, list, set

# int_num = 5
# float_num = 3.5

# # В этом случае на скрытном уровне произойдет то, что ниже.
# print(int_num + float_num)

# # оператор "+" заменяется на магический метод __add__, но здесь будет ошибка, т.к. у класса int нет возможности сложить
# int с float
# print(int_num.__add__(float_num))
# print(float_num.__radd__(int_num))  # а у класса float такая возможность есть.


# 40. Введение в магические методы.

# int_num = 5
# float_num = 10.5

# print(int_num * float_num)
# Вот так нельзя, т.к. в типе int. не реализована возможность * на другие типы. __mul__ это умножение, типа multiply
# print(int_num.__mul__(float_num))
# А вот так можно, потому что в float есть такая возможность. На самом деле и __mul__ тоже здесь сработает.
# print(float_num.__rmul__(int_num))

# Прикол, если множить int на str, то str столько раз подряд будет, сколько int.
# int_num = 5
# str_val = 'abc'
# если множители местами поменять, будет то же самое. Но важно то, что функционал умножения int на str сделан только в str.
# print(int_num * str_val)
# print(int_num.__mul__(str_val))  # Т.е. вот так не сработает
# print(str_val.__rmul__(int_num))  # А вот так норм.
#  Но если float*str, то ничего не получится. В __rmul__ для str не реализован такой функционал.
# float_num = 5.4
# str_val = 'abc'
# print(float_num.__mul__(str_val))
# print(str_val.__rmul__(float_num))  # Т.е. ошибка вот тут вылезет


# 41. Магические методы - это методы внутри определенного класса, и они обычно не вызываются явно.

# В данном случае __doc__ это не метод, а атрибут, который содержит строку. Он выводит информацию по определенному методу
# или классу хз.
# Тут str это и метод класса str, на основании которого можно создавать другие методы.
# print(str.__doc__)

# Можно получить справку о каждом магическом методе любого класса.
# my_list = []

# print(help(my_list.__eq__))  # Вот таким образом.


# 42. Списки. Список - это упорядоченное расположение элементов. Если в списке 3 одинаковых элемента, но по-разному расположены,
# это разные списки.
# print([1, 2, 3] == [3, 2, 1])  # Будет False.

# my_fruits = ['apple', 'orange', 'pineapple']
# print(len(my_fruits))  # len считает количество элементов.

# post_ids = [144, 134, 165]
# print(post_ids[1])  # Вот так можно получить элемент списка определенный.

# А вот так можно заменять элемент списка
# post_ids = [144, 134, 165]
# post_ids[0] = 345  # В данном случае мы изменили объект, выполнили мутацию.

# Вот так можно удалить элемент списка.
# post_ids = [144, 134, 165]
# del post_ids[-1]

# Часто приходится создавать словари в списках.
# user_list = [
#     {
#         'user_id': 134,  # В словарях не забываем ключ: значение.
#         'user_name': 'Alice'
#     },
#     {
#         'user_id': 562,
#         'user_name': 'Niko'
#     }
# ]

# print(len(user_list))  # Смотрим сколько элементов списка
# # Выводим в первом элементе значение ключа user_name.
# print(user_list[0]['user_name'])


# 43 Методы списков. Каждый список является экземпляром класса list.

# values_count = []
# values_count.append(1)  # Метод append добавляет элемент в конец списка.
# values_count.append(3)
# values_count.append(2)
# print(values_count)

# print(len(values_count))

# inputs = [1, 'hi', True, 10.4]
# inputs.pop(0)
# inputs.pop()  # Удалит последний элемент списка
# # Вводим переменную и присваиваем ей удалённое значение списка
# removed_element = inputs.pop()

# print(removed_element)

# И pop и append изменяют список, но не создают новый объект

# post_ids = [1, 24, 534, 25, 18]
# test = post_ids.sort()  # Метод sort без аргумента отсортирует список от мала до велика.

# # А вот с таким аргументом задом наперед будет
# okety = post_ids.sort(reverse=True)

# print(id(post_ids))
# print(id(test))  # метод sort изменяет объект
# print(id(okety))  # странно, но этот объект имеет тот же номер.


# 44. Разные операции со списками
# Вот таким образом можно переконвертировать объект класса str в list
# greeting = 'Hello from Python'
# greeting_list = list(greeting)

# print(greeting_list)

# А вот так можно переконвертировать словарь в список
# dict = {'a': 10, 'b': 'hi'}
# dict_list = list(dict)  # В список переносятся только ключи словаря.

# print(dict_list)

# ratings = [1.2, 5.4, 3.2, 8.9]
# print(min(ratings))  # Минимальное списка
# print(max(ratings))  # Максимальное списка
# print(sum(ratings))  # Сумма элементов списка
# print(sum(ratings)/len(ratings))  # Сумму списка разделить на кол-во элементов

# Объединение двух и более списков
# first_list = [1.2, 5.4, 3.7]  # Новый объект
# second_list = [3.3, 'a', True]  # Новый объект
# sum_list = first_list + second_list  # Потому что работает магический метод.
# print(sum_list)  # Новый объект

# Нарезка списков в пайтоне
# common_list = [1.2, 4.3, 5.6, 2.8, 6.3]
# first_list = common_list[:2]
# second_list = common_list[-2:]
# third_list = common_list[0:3]  # В каждом этом случае создастся новый объект
# forth_list = common_list[:]  # Все-равно в этом случае создастся новый объект

# print(first_list, second_list, third_list, forth_list)

# 45. Копирование списков

# my_cars = ['BMW', 'Haval']
# Таким образом произойдёт копирование по ссылке, новый объект не создастся
# new_cars = my_cars
# а вот так создастся новый объект. Это копирование, используя slice (нарезку)
# new_cars = my_cars[:]
# new_cars = my_cars.copy()  # это тоже самое, что и [:]. Предпочтительный вариант, потому что явно видно, что копируем список
# new_cars = list(my_cars)  # тоже самое

# new_cars.append('Audi')

# print(new_cars, my_cars)
# print(my_cars == new_cars)


# 46. Практика - списки.

# res = [4, 4, 9, 0, 12, 15]
# check = res.count(4)  # Возвращает кол-во таких элементов
# Добавляет элемент в конец списка. Если присвоить переменную этому, то не получится
# res.append(10)
# res.insert(2, -5)  # добавляет элемент перед определённым индексом.
# res.clear()  # очищает список
# res.extend('abc')  # добавляет в конец списка элементы из строки.
# print(res)

# res_2 = res.copy
# print(id(res), id(res_2))
# print(len(res))


# 47. Задачи - списки.
# Задача 1:
# 1. Создать список с 5 элементами разных типов
# first_list = [1, 2.3, 'ok', True, [4, 5.3]]
# 2. Удалить третий элемент
# first_list.pop(2)
# 3. Вывести в терминал длину списка
# print(len(first_list))
# 4. Поменять порядок следования элементов в списке
# first_list.reverse()  # Реверс создаёт новый объект
# 5. Создать еще один список с двумя элементами
# second_list = [3, 6.4]
# 6. Расширить первый список элементами второго списка. Т.е. мутировать его, а не создавать другой список.
# при этом в первом списке будет 6 элементов.
# Апенд создаёт новый объект, решение не верное.
# first_list.append(second_list)  # так не буду делать, т.к. в списке список будет из 5 элементов
# first_list.append(3)
# first_list.append(6.4)
# print(first_list)


# Задача 2:
# 1. Создать 2 списка
# one_list = [1, 2, 3]
# two_list = [4, 5]
# 2. Объединить 2 списка, используя оператор +
# sum_list = one_list + two_list
# 3. Определить, какой магический метод списков вызывается при использовании оператора +
# .__add__
# 4. Выполнить слияние списков, используя этот магический метод.
# Тут без разницы, первый или второй сначала будет.
# sum_list = two_list.__add__(one_list)
# 5. Результат вывести в терминал.
# print(sum_list)


# 48. Словари.
# Это неупорядоченная последовательность элементов. У элементов нет индексов.
# Значения в словарях могут быть разных типов, даже словарь, список, функция
# Если больше 2х ключей, лучше размещать словарь на разных строках кода
# Порядок элементов в словаре не имеет значения, у пары ключ-значение нет уникальных индексов

# my_motorbyke = {
#     'name': 'Ducati',
#     'price': 25000,
#     'engine_vol': 1.2,
# }
# other_motorbyke = {
#     'engine_vol': 1.2,
#     'price': 25000,
#     'name': 'Ducati',
# }

# print(my_motorbyke == other_motorbyke)  # Словари одинаковые
# print(id(my_motorbyke))  # Но объекты разные
# print(id(other_motorbyke))


# 49. Изменение и удаление значений в словарях
# my_motorbyke = {
#     'name': 'Ducati',
#     'price': 25000,
#     'engine_vol': 1.2,
# }

# # Чтобы вызвать значение ключа словаря, нужно обращаться к нему через []
# print(my_motorbyke['name'])
# # В объектах с помощью точки можно получать доступ к атрибутам объекта. Для словарей ключи это не атрибуты
# my_motorbyke['price'] = 30000
# my_motorbyke['years'] = 2  # Вот так добавляется новое значение в словарь
# # Для удаления элемента используется оператор del
# del my_motorbyke['engine_vol']
# print(my_motorbyke)


# 50. Использование переменных в словарях
# my_motorbyke = {
#     'name': 'Ducati',
#     'price': 25000,
#     'engine_vol': 1.2,
# }

# short = my_motorbyke['name']  # Через переменную получили доступ к элементу
# print(short)

# # Или вот так:
# key_name = 'name'
# my_motorbyke[key_name] = 'BMW'  # Заменяем значение ключа на новый
# print(my_motorbyke['name'])

# Можно использовать вложенные словари вот так:
# my_motorbyke = {
#     'name': 'Ducati',
#     'engine_vol': 1.2,
#     'price_info': {
#         'price': 25000,
#         'is availvable': True
#     }
# }

# # Обращаться к нужному ключу нужно каскадно
# print(my_motorbyke['price_info']['price'])

# А можно сначала создать переменные, присвоить им значения и далее использовать переменные в словарях в качестве значений
# name = 'Ducati'
# engine_vol = 1.2
# price = 25000

# my_motorbike = {
#     'name': name,
#     'engine_vol': engine_vol,
#     'price': price
# }

# print(my_motorbike)


# 51. Длина словаря

# my_motorbyke = {
#     'name': 'Ducati',
#     'engine_vol': 1.2,
#     'price': 20000
# }

# print(len(my_motorbyke))  # с помощью функции len
# del my_motorbyke['name']
# print(len(my_motorbyke))


# 52. Несуществующие ключи и метод get

# my_motorbyke = {
#     'name': 'Ducati',
#     'engine_vol': 1.2,
#     'price': 20000
# }

# # print(my_motorbyke['is_available'])  # Если ключа нет, получим ошибку
# # Если не знаем, есть ли ключ, надо использовать метод get()
# print(my_motorbyke.get('is_available'))
# # Если значения нет, то можно поставить любое значение по-умолчанию
# print(my_motorbyke.get('is_available', 0))


# 53. Резюме по словарям
# dic = {}
# # Это описание функции dict, с помощью которой можно создавать словари
# print(dic.__doc__)


# 54. Практика - словари
# my_disc = {}

# print(id(my_disc))
# print(type(my_disc))

# my_disc['price'] = 80
# my_disc['brand'] = 'Samsung'

# print(my_disc)
# print(id(my_disc))
# или можно написать my_disc. - тоже покажет какие методы есть.
# print(dir(my_disc))
# или можно написать dict и навести мышкой, тоже выведется что делает эта функция.
# print(my_disc.__doc__)

# Метод .items возвращает спец. объект (кортеж), кот. является экземпляром класса dict_items
# print(my_disc.items())
# результат метода items является объектом класса dict_items
# print(type(my_disc.items()))
# print(my_disc.keys())  # Вызывает ключи словаря
# print(type(my_disc.keys()))
# keys_list = list(my_disc.keys())  # Изменить тип на список
# print(list(my_disc.keys()))  # Ну или так изменить тип
# print(keys_list)
# Вызывает кортеж вместо словаря и удаляет последний элемент списка, не рекомендуется использовать, мы можем не знать,
# какой элемент был добавлен последним
# print(my_disc.popitem())
# print(my_disc)
# print(my_disc.get('price'))
# Если нет ключа, можно передавать значение по-умолчанию
# print(my_disc.get('type', 'hdd'))


# 55. Практика. Копирование словаря
# my_disc = {}
# my_disc['price'] = 80
# my_disc['brand'] = 'Samsung'

# new_disc = my_disc.copy()
# new_disc['type'] = 'SSD'
# print(my_disc)
# print(new_disc)
# print(len(my_disc))


# 56. Практика. Конвертация других значений в словарь.
# Можно переконвертировать список списка (кортеж списка, кортеж кортежа, список кортежа) в словарь.
# my_list = [('First', 0), ['Second', True]]
# my_dict = dict(my_list)
# print(my_dict)


# 57. Задача - словари.
# 1. Создать пустой словарь
# new_dict = {}
# # 2. Трижды попросить пользователя сначала ввести название ключа, а потом ввести значение для этого ключа.
# # Всего должно быть 6 запросов на ввод текста.
# key_1 = input('Введите первый ключ словаря: ')
# value_1 = input('Введите первое значение словаря: ')
# new_dict[key_1] = value_1
# key_2 = input('Введите второй ключ словаря: ')
# value_2 = input('Введите второе значение словаря: ')
# new_dict[key_2] = value_2
# key_3 = input('Введите третий ключ словаря: ')
# value_3 = input('Введите третье значение словаря: ')
# new_dict[key_3] = value_3
# # 3. Во время получения данных от пользователя добавляйте в словарь ключи с значениями согласно тому, что ввел пользователь
# # 4. Выведите результирующий словарь в терминал.
# # print(new_dict)
# # 5. Добавить еще пару ключей и удалить 3 ключа.
# new_dict['Car'] = 'Ferrari'
# new_dict['Is_new'] = 'False'
# del new_dict[key_1]
# del new_dict[key_2]
# print(new_dict)


# 58. Кортежи (tuple)
# Кортеж это упорядоченная последовательность элементов, но кортеж нельзя изменять (удалять, добавлять),
# в отличие от списков. В кортежах могут быть элементы разных типов. Количество может быть любым, но обычно
# 2-4 элемента
# Порядок следования элементов важен
# new_tuple = (1, 3, 5, 'ile', True)
# print(new_tuple[3:])  # Получить значение элемента кортежа
# new_tuple[2] = 10  # Поменять значение кортежа нельзя, будет ошибка
# del new_tuple[-1]  # Удалять элементы нельзя, будет ошибка

# Если в кортеже находятся словари или списки (изменяемые объекты), значения в них можно изменить.
# users = (
#     {
#         'user_1': 'Alice',
#         'age_1': 24
#     },
#     {
#         'user_2': 'Nick',
#         'age_2': 34
#     }
# )

# # Просто смотрим значение первого ключа во втором словаре
# print(users[1]['user_2'])
# users[1]['age_2'] = 36  # Меняем значение второго ключа второго словаря
# print(users[1])  # Смотрим значение второго словаря
# # При этом в кортеж users нельзя добавить новые словари или удалить существующие

# Можно использовать переменные для формирования кортежей
# fruit_1 = 'banana'
# fruit_2 = 'apple'
# fruit_3 = 'orange'
# my_fruits = (fruit_1, fruit_2, fruit_3)
# print(my_fruits)

# ids = (324, 152, 166, 363)
# print(ids[10])
# Нельзя к несуществующему элементу обращаться, ошибка будет. Метод .get не работает в кортежах.
# Можно узнать длину len(ids) и сравнить if len-1 < 10, то ок.

# Сложение кортежей
# nums_1 = (1, 2, 3)
# nums_2 = (4, 5)
# nums_sum = nums_1 + nums_2  # Вот так, при этом работает метод .__add__
# print(nums_sum)


# 59. Методы кортежей
# tup = (1, 2, 22, 2, 3, 4, 1)
# print(tup.count(2))  # count считает кол-во таких элементов
# # index показывает какой по счёту стоит элемент. Если несколько, то первый.
# print(tup.index(2))

# Можно изменить кортеж путём конвертации его в список и обратно
# tup = (1, 2, 3)
# tup_list = list(tup)
# tup_list.insert(1, -5)  # Методом insert вставляем куда угодно в список элемент
# print(type(tup_list))
# tup = tuple(tup_list)
# print(type(tup))
# print(tup)


# 60. Практика кортежей
# my_nums = (10, 5, 100, 0, 5, 5)
# index_1 = my_nums.index(5)  # Находит только первый элемент в кортеже
# # Находит элемент начиная с index_1 включительно, поэтому прибавляем + 1. Второй аргумент показывает, с какого элемента
# # начинать поиск индекса в кортеже
# index_2 = my_nums.index(5, index_1 + 1)  # Покажет 4
# index_3 = my_nums.index(5, index_2 + 1)  # Покажет 5
# print(index_3)


# my_tuple = tuple('abc')  # Можно преобразовывать строку в кортеж
# print(my_tuple)
# # И словарь в кортеж можно преобразовать
# sec_tuple = tuple({'name': 'Nik', 'surname': 'Sim'})
# print(sec_tuple)

# tuple_1 = (1, 1.3, True, 'abc')
# tuple_2 = (None, {'one': 'two'}, (1, 5, 3))
# tuple_sum = tuple_1 + tuple_2  # Можно складывать кортежи с разными объектами
# print(tuple_sum)


# 61. Наборы (set)
# Это неупорядоченная последовательность элементов, у элементов нет индексов.
# Набор содержит только уникальные элементы. При создании набора можно повторять их, но при выводе в терминал будут только
# уникальные. Дубликаты будут удалены автоматически.
# Если в набор добавить элемент, который уже есть - такой элемент добавлен не будет
# Наборы можно изменять
# В наборах обычно сохраняют однотипные данные
# Преимущество в том, что можно из большого списка разных значений (в том числе повторяющихся) сделать набор, в
# котором останутся только уникальные.
# Часто используются для обработки данных и машинного обучения

# my_fruits = {'apple', 'banana', 'orange'}
# other_fruits = {'banana', 'apple', 'orange'}
# print(my_fruits == other_fruits)
# print(len(my_fruits))
# print(my_fruits[0])  # Будет ошибка, по индексу элемент получить нельзя


# 62. Практика - проверка неупорядоченности наборов
# post_ids = {244, 133, 166}
# Будет ошибка, т.к. это неупорядоченный объект. У класса set нет магического метода .__getitem__
# post_ids[1]
# У списков есть .__getitem__, например:
# post_ids = [244, 133, 166]
# print(post_ids[0])
# То же самое, что обращаться к элементу post_ids[0]
# print(post_ids.__getitem__(0))


# 63. Изменяемые объекты в наборах
# В набор нельзя добавлять изменяемые объекты (списки, наборы, словари)
# Для того, чтобы проверять уникальность элементов, в наборах для каждого элемента генерируется хэш.
# И этот хэш не изменяется, пока элемент есть в наборе. Если элемент мы меняем, хэш меняется, а это недопустимо.
# В наборах могут содержаться только строки и целые числа?, наборы, флоаты, кортежи, т.е. неизменяемые объекты.


# 64. Практика - наборы.
# В наборах нельзя использовать оператор удаления определённого элемента del. Вместо него метод discard
# Для удаления элементов в наборе есть свои элементы класса set
# В наборах могут быть кортежи.
# my_set = {(10, 2), 5, 5, 10}
# print(my_set)

# Если мы хотим вызвать пустой набор, нужно вызывать его через класс set
# Set это функция-конструктор, с помощью которой создаются экземпляры класса set
# empty_set = set()
# print(empty_set)


# 65. Методы наборов.
# Именно методы наборов делают этот класс мощным инструментом, который часто используется в пайтон
# Добавлять элементы в набор можно с помощью метода add
# my_set = {'one', 'two'}
# my_set.add('three')
# print(my_set)

# С помощью union можно объединять наборы. Или с помощью оператора |. Оригинальные наборы при этом не меняются.
# my_set = {1, 2}
# other_set = {2, 3}
# sum_set = my_set.union(other_set)
# sum_set = my_set | other_set
# print(sum_set)

# Пересечение наборов (что общего) с помощью метода intersection или оператора &. Оригинальные наборы при этом не меняются.
# set_one = {1, 2, 3}
# set_two = {2, 3, 4}
# inter_set = set_one.intersection(set_two)
# inter_set = set_one & set_two
# print(inter_set)
# При вызове intersection можно передавать любую последовательность - строки, списки, кортежи...

# issubset проверяет включен ли один набор в другой набор (подмножество множества). Или наоборот issuperset
# nums = {10, 5, 15}
# supernums = {3, 5, 10, 15, 20}
# res = nums.issubset(supernums)
# print(res)


# 66. Практика - методы наборов
# my_set = {'abc', 'd', 'f', 'y'}
# other_set = {'a', 'f', 'd'}
# Вернёт только 'd', т.к. 'abcd' будет разбито по итерациям 'a', 'b', 'c', 'd'. А в my_set есть только элемент 'd'
# print(my_set.intersection('abcd'))
# Чем отличается одно множество от другого. Можно использовать также оператор -
# print(my_set.difference(other_set))
# print(my_set - other_set)
# Метод discard убирает указанный элемент и возвращает значение None.
# Если такого элемента в наборе нет, ничего страшного, ошибки не будет
# print(my_set.discard('d'))
# print(my_set)
# Метод remove тоже удаляет элемент, но если такого элемента в наборе нет, будет ошибка, в отличие от discard
# print(my_set.remove('xyz'))
# print(my_set.remove('abc'))
# copied_set = my_set.copy()  # Метод copy копирует набор
# my_set.add('w')  # И можно оба набора независимо изменять.
# copied_set.add('z')
# print(my_set)
# print(copied_set)


# 67. Практика - симметричная разница в наборах
# my_set = {'abc', 'd', 'f', 'y'}
# copied_set = my_set.copy()  # Метод copy копирует набор
# my_set.add('w')  # И можно оба набора независимо изменять.
# copied_set.add('z')
# Этот метод возвращает то что есть уникального в двух множествах
# print(my_set.symmetric_difference(copied_set))
# Оно же самое = объединение множеств минус их пересечение
# a = my_set
# b = copied_set
# print((a | b) - (a & b))


# 68. Задача - наборы
# 1. Создать набор из нескольких элементов типа int
# first_set = {20, 5, 10, 8}
# 2. Добавить в него ещё один элемент
# first_set.add(16)
# 3. Создать ещё один набор с несколькими элементами, причём некоторые должны быть
# такими же, как в первом наборе
# second_set = {40, 30, 20, 10, 19}
# 4. Найти общие элементы в двух наборах и поместить их в новый набор
# new_set = list(first_set.intersection(second_set))
# 5. Конвертировать результирующий набор в список и вывести список в терминал
# print(new_set)
# 6. Сделать ещё несколько каких-нибудь действий по моему желанию.
# print(type(new_set))
# new_set.append(17)
# new_set.append(17)
# new_set.extend('abc')
# new_set = set(new_set)
# print(type(new_set))
# print(new_set.issuperset(first_set))


# 69. Диапазоны (range)
# Это упорядоченная неизменяемая последовательность элементов
# В диапазоне все элементы уникальны. По-умолчанию шаг единица, можно задать другой
# my_range = range(7)  # Если один элемент - это конец диапазона
# print(type(my_range))
# print(my_range)  # range(0, 7)
# print(list(my_range))  # [0, 1, 2, 3, 4, 5, 6]

# первый элемент начало диапазон, второй - конец, третий - шаг диапазона
# my_range = range(10, 20, 3)
# print(list(my_range))
# print(my_range[1])

# 70. Практика - диапазоны
# my_range = range(10, 25, 3)
# for n in my_range:  # Можно также написать for n in range(5):
#     print(n)
# print(list(range(12, 22, 4)))  # Сразу список выведется.
# Методы диапазонов
# print(dir(my_range))
# print(my_range.start)  # Атрибут диапазона и ниже тоже стоп и степ
# print(my_range.stop)
# print(my_range.step)
# print(my_range.index(13))  # Выведет какой по счёту в диапазоне этот элемент
# print(my_range.count(16))  # Считает сколько таких элементов

# Ниже задача создать диапазон, список, и перебором цикла for занести данные из диапазона в список
# test_range = range(7, 64, 5)
# my_list = []
# for n in test_range:
#     my_list.append(n)
# print(my_list)


# 71. Сравнение типов последовательностей  - см. important.py


# 72. Встроенная функция zip
# Можно формировать новые объекты на основании других последовательностей, т.е. объединять последовательности вместе.
# При конвертации zip объекта в список получается список кортежей
# fruits = ['banana', 'apple', 'grape']
# quantities = [100, 200, 300]
# # даже если кортеж поставим, результат будет тот же.
# availability = [True, False, True]
# # Можно хоть строку добавлять str.
# # Получился объекта класса zip, но его не видно, выводится только адрес объекта
# fruit_qty_zip = zip(fruits, quantities, availability)
# print(fruit_qty_zip)
# fruit_qty_list = list(fruit_qty_zip)
# # При этом попарно объединяются в кортеж элементы из обоих списков
# print(fruit_qty_list)
# # Но если в одном списке больше элементов, чем в другом, избыточные элементы будут проигнорированы.


# 73. Конвертация zip в dict
# fruits = ['banana', 'apple', 'grape']
# quantities = [100, 200, 300]
# fruit_qty_zip = zip(fruits, quantities)
# Если сделать таким образом, получится прекрасный словарь
# fruit_qty_dict = dict(fruit_qty_zip)
# print(fruit_qty_dict)

# Задание. Создать 2 списка, в одном будут названия товаров из магазина, а во втором цены на них.
# Объединить оба списка с помощью zip
# Затем конвертировать сначала в список, а потом в словарь (не последовательно) и вывести это в терминал.
# goods = ['spoon', 'fork', 'knife']
# prices = [50, 35, 90]
# goods_zip = zip(goods, prices)
# goods_list = list(goods_zip)
# print(goods_list)
# goods_dic = dict(goods_zip)
# print(goods_dic)


# 74. Изменение объектов в пайтон
# У неизменяемых объектов типа int объект один, а переменные могут быть разные
# a = 5
# b = 5
# b += 5  # Но в этом случае создастся другой объект

# 75. Поведение изменяемых объектов
# list_one = [1, 2, 3]
# list_two = [1, 2, 3]  # Хоть списки похожи, но объекты разные.
# print(id([1, 2, 3]))  # Это ещё один объект
# Каждый изменяемый объект может быть изменён независимо, даже если значения изначально одинаковые
# А если мы создадим 1 объект и потом его создадим другую переменную со ссылкой на этот же объект, можно
# будет изменять этот объект путём изменения любой из ссылок, вот так:
# list_one = [1, 2, 3]
# list_two = list_one  # т.е. это будет один и тот же объект
# list_two.append(4)
# print(id(list_one))
# print(id(list_two))
# print(list_one)
# print(list_two)


# 76. Как избежать изменения копий
# Первый вариант - не использовать изменяемые объекты в словаре, тогда копия не поменяет оригинал.
# my_dict = {
#     'name': 'Nick',
#     'years': 36,
# }
# second_dic = my_dict.copy()
# second_dic['happy'] = True
# print(my_dict)
# print(second_dic)

# Второй вариант. Но если у словаря есть изменяемые объекты в качестве значений, то при изменении скопированного
# словаря, изменится и оригинальный (т.е. избежать изменения оригинала не получится), например:
# my_dict = {
#     'name': 'Nick',
#     'years': 36,
#     'hobbies': [],
# }
# second_dic = my_dict.copy()  # Это поверхностная (shallow) копия
# second_dic['hobbies'].append('different')  # Можно или так сделать - добавить. Причём метода append у словаря нет, а мы
# его тут использовали, и он сработал
# second_dic['hobbies'] = ['different']  # Или вот так - заменить.
# print(my_dict)  # Видно, что изменился оригинал
# print(second_dic)

# И чтобы этого не происходило, есть встроенный в пайтон модуль copy
# from copy import deepcopy  # Импортируем оттуда функцию deepcopy
# my_dict = {
#     'name': 'Nick',
#     'years': 36,
#     'hobbies': [],
# }
# second_dic = deepcopy(my_dict)
# second_dic['hobbies'].append('different')
# print(my_dict)
# print(second_dic)


# 77. Практика - создание поверхностных и полных копий (см. 76)

# 78. Функции.
# Это блок кода, который можно выполнять многократно, даже с различными вводными данными
# Функция это объект класса function
# Функция возвращает None если нет ключевого слова return
# def sum(a, b):  # В скобках параметры функции
#     c = a + b  # Всё, что в функции - тело функции
#     print(c)


# a = 5
# b = 3
# sum(a, b)
# print(type(sum))

# Или так:


# def sum(a, b):  # Аргументы опционально. Т.е. когда мы функцию вызываем, это уже аргументы, а не параметры
#     c = a + b
#     return c  # На return функция прекращает свою работу. Опционально


# a = 5
# b = 3
# res = sum(a, b)  # Опционально присвоить результат функции переменной
# print(res)  # И выводить переменную в консоль


# 79. Самая короткая функция и pass
# Согласно требованиям пайтон, в каждом блоке кода (пр. в теле функции) была одна строка кода
# def my_fn():
#     pass  # Это ключевое слово. Если пока не определились, что будет делать функция


# print(my_fn())


# 80. Передача неизменяемых объектов в функцию.
# def my_fn(a, b):
#     a = a + 1  # После выполнения этой строки видно, что id объекта а + 1 отличается от num_one
#     print(id(a))
#     c = a + b
#     return c


# num_one = 10
# num_two = 5
# # Учитель говорил, что num_one это просто ссылка на объект 10, который не изменяется. И в функции создастся новый объект,
# # где a = a + 1. Внутри функции мы не изменим внешние неизменяемые объекты.
# res = my_fn(num_one, num_two)
# print(res)
# print(num_one)
# print(id(num_one))


# 81. Передача изменяемых объектов в функцию.
# Не рекомендуется при помощи функций менять внешние переменные (объекты). Но ниже именно так и происходит
# При изменении параметров внутри функции, мы не меняем внешние объекты напрямую, но при работе с изменяемыми объектами
# снаружи функции, они также изменятся.
# def increase_person_age(person):
#     print(id(person))  # id параметра person сходно с объектом person_one
#     person['age'] += 1
#     return person


# # Тут будет ошибка, потому что переменная person определена только внутри функции
# # print(person)

# person_one = {
#     'name': 'Nick',
#     'age': 35,
# }
# print(id(person_one))
# # Изменение внешнего объекта происходит внутри функции
# increase_person_age(person_one)
# print(person_one)


# 82. Как избежать изменения внешних объектов в функции
# def increase_person_age(person):
#     # Функция создаёт новую переменную, копию атрибута. Вне функции этой переменной не существует.
#     test_person = person.copy()  # если в словаре есть вложенные словари, или списки, или другие изменяемые объекты,
#     # лучше использовать full copy
#     test_person['age'] += 1  # к новой переменной прибавляет 1 к списку ключа
#     return test_person  # Возвращает новую переменную полностью (список)


# old_person = {
#     'name': 'Nick',
#     'age': 35,
# }
# # Создаём новую переменную. Без неё функция просто выполнится, но ничему не присвоится (ссылке)
# new_person = increase_person_age(old_person)
# print(new_person['age'])
# print(old_person['age'])
# print(id(new_person['age']))
# print(id(old_person['age']))  # Видно, что сам изначальный объект не изменился.


# 83. Задача - функции
# 1. Создать функцию merge_list_to_dict
# 2. У функции должно быть 2 параметра
# 3. Функция должна объединять 2 списка, используя встроенную функцию zip
# 4. Конвертировать объект zip в словарь и вернуть его из функции
# 5. Вызвать функцию, передав ей 2 списка в качестве аргументов
# 6. Вывести результат вызова функции в терминал
# def merge_list_to_dict(a, b):
#     merged_zip = zip(a, b)
#     merged_list = list(merged_zip)
#     return merged_list
# # Здесь смысла копию создавать нет, т.к. исходные списки не изменяются, создаётся объект zip


# list_one = ['Nick', 'Vova', 'Lera']
# list_two = ['36', '39', '7']
# merged_final_list = merge_list_to_dict(list_one, list_two)
# print(merged_final_list)


# 84. Аргументы функций.
# def = func(a, b)  вот эти параметры, а в последствии при вызове аргументы являются позиционными, т.к. их позиция важна
# Нельзя передавать в функцию больше или меньше аргументов, чем есть параметров в функции.


# 85. Объединение всех аргументов в кортеж в функции.
# def sum_nums(*args):  # Тут всё равно, что будет написано после *
#     print(args)
#     print(type(args))
#     print(args[-2])
#     print(sum(args))  # Или тут возвращать sum(args)


# sum_nums(2, 8, 11, 6)  # Или тут ещё выводить результат в консоль

# def posts_qty(name, qty):
#     post = f'{name} wrote {qty} posts'  # функция f strings позволяет динамически формировать строки на основании
#     # различных выражений
#     return post


# text = posts_qty('Nick', 30)
# print(text)


# 86. Аргументы с ключевыми словами (key word arguments)
# Использование аргументов с ключевыми словами делает код более читабельным.
# def posts_qty(name, qty):
#     # Здесь в 3х случаях должно совпадать - параметр, аргумент и эта строка
#     post = f'{name} wrote {qty} posts'
#     return post


# # Когда мы присваиваем аргументу значение - это называется key word arguments. Порядок элементов не важен.
# text = posts_qty(qty=25, name='Nick')
# print(text)


# 87. Объединение именованных аргументов в словарь
# def get_posts_info(**person):  # оператор ** объединяет аргументы в словарь.
#     print(person)
#     print(type(person))
#     info = (  # Это не кортеж, это для объединения f-string
#         f'{person['name']} wrote '
#         # Если мы заменим или тут, или на строке с аргументами на f'{person.get(qty_n)} posts', то будет None
#         f'{person['qty']} posts'
#     )
#     return info


# # Ну вот так можно связать аргументы с параметрами в словарь. Можем передать больше аргументов в вызове функции, но
# # если в самой функции параметр не будет задействован, он не обработается. Если мы используем позиционный аргумент, хотя
# # в функции указывали ** параметр, будет ошибка
# info = get_posts_info(name='Nick', qty=46, id=153)
# print(info)


# 88. Задачи - именованные аргументы функций
# Задача 1:
# 1. Переписать вызов функции merge_lists_to_dict из предыдущей задачи так, чтобы в нём использовались аргументы
# с ключевыми словами. Названия должны быть осмысленными.
# 2. Добавить ещё один вызов функции, в котором будет один позиционный аргумент, а второй - аргумент с ключевым словом.
# def merge_list_to_dict(names, years):
#     merged_zip = zip(names, years)
#     merged_list = list(merged_zip)
#     return merged_list


# merged_final_list = merge_list_to_dict(
#     names=['Nick', 'Vova', 'Lera'], years=['36', '39', '7'])
# print(merged_final_list)

# Задача 2:
# 1. Создать функцию update_car_info, в которой все именованные аргументы будут объединяться в словарь car
# 2. Добавить в словарь новый ключ is_available со значением true (внутри функции)
# 3. Вернуть из функции изменённый словарь
# 4. Вызвать функцию с именованными аргументами brand и price, их значения могут быть любыми.
# 5. Вывести в терминал результат функции
# def update_car_info(**car):
#     car['is_available'] = True
#     return car


# offer = update_car_info(brand='Atom', price=20000)
# print(offer)


# 89. Значения параметров функции по-умолчанию
# Где второй параметр после = это устанавливается значение по-умолчанию
# def mult_by_factor(value, multiplier=1):
#     return value * multiplier


# # Если второй аргумент есть, значение по-умолчанию для 2-го параметра не работает
# print(mult_by_factor(5, 2))
# print(mult_by_factor(5))
# Наличие значения по-умолчанию у параметра функции делает его необязательным (часто ставят None)
# Ниже просто пример.

# from datetime import date  # Импортируем объект (метод) date из модуля datetime


# def get_weekday():  # Создаём функцию, будет возвращать день недели.
#     return date.today().strftime('%wth of %B %Y, %A')


# # В качестве второго параметра - функция (возвращает день недели)
# def create_new_post(post, weekday=get_weekday()):
#     post_copy = post.copy()  # Делаем копию списка, чтобы не изменять исходный объект
#     # добавляем значение функции в новый ключ
#     post_copy['created_on_weekday'] = weekday
#     return post_copy


# initial_post = {
#     'id': 243,
#     'Author': 'Nick',
# }
# post_with_weekday = create_new_post(
#     initial_post, 'Monday')  # Только один аргумент
# print(post_with_weekday)


# 90. Практика - Значения параметров по-умолчанию.
# Задание - найти в нете инфо по методу today для объекта date, найти варианты, как можно отформатировать результат,
# который возвращает метод today (дату)
# Вот тут хорошо написано, почитать https://code.mu/ru/python/manual/time/datetime/today/
# print(get_weekday())


# 91. Callback функции
# Это функция, которая передаётся как аргумент в другую функцию и там вызывается.
# def other_fn():  # Вот это колбэк функция
#     pass


# def fn_with_callback(callback_fn):
#     callback_fn()


# fn_with_callback(other_fn)

# Ещё пример колбэк функции
# def print_number_info(num):
#     if (num % 2) == 0:  # Если параметр делится на 2 без остатка, то:
#         print('Entered number is even')  # Число парное
#     else:
#         print('Entered number is odd')  # Число непарное


# def print_square_num(num):
#     print('Square of the num is', num * num)

# # num == entered_num. А callback_fn возьмёт этот num и закинет его в num функции print_number_info


# def process_number_info(num, callback_fn):
#     callback_fn(num)  # Второй параметр вызывает аргумент num


# entered_num = int(input('Enter any number: '))  # Переводим инпут в интеджер.
# # Первый аргумент это то, что ввёл пользователь, второй аргумент колбэк функция.
# process_number_info(entered_num, print_number_info)
# process_number_info(entered_num, print_square_num)


# 92. Практика - колбэк функции (см. 91)
# def send_data(data):
#     pass  # это будет типа функция,  которая отправляет данные на сервер


# def process_data(input_data, send_data_fn):
#     updated_data = input_data.copy()
#     # Копирует данные, можно их изменить и дальше отправляет обновленные данные в функцию send_data.
#     send_data_fn(updated_data)


# process_data({'name': 'Nick'}, send_data)


# 93. Правила работы с функциями.
# 1. Называть функции исходя из выполняемых задач
# 2. Название функции начинать с глагола
# 3. Одна функция должна выполнять одну задачу (single purpose)
# 4. Не рекомендуется изменять внешние относительно функции переменные (pure function).


# 94. Документация функции docstring
# Описание функции - что она делает, и всплывали подсказки с описанием например аргументов этой функции
# Используется для описания функций, классов, модулей.
# Всё, что между тройными кавычками - это описание функции можно самому делать
# def print_number_info(num):
#     """"
#     Prints whether number is even or odd

#     Args:
#         num (int): Numbers to be evaluated
#     """
#     if (num % 2) == 0:
#         print('Entered number is even')
#     else:
#         print('Entered number is odd')


# print_number_info(10)

# Или вот так, я поставил расширение autodocstring. Делаем тройные кавычки и нажимаем.


# def print_number_info(num):
#     """
#     Prints whether number is even or odd

#     Args:
#         num (int): Numbers to be evaluated
#     """
#     if (num % 2) == 0:
#         print('Entered number is even')
#     else:
#         print('Entered number is odd')


# print_number_info(10)


# 95. Области видимости
# Область видимости определяет границы видимости (доступности) переменной
# В разных областях видимости можно создавать переменные с одинаковыми именами (глобальная-локальная, разные локальные)
# Если мы обратимся к переменной си в локальной области видимости, где её нет, то пайтон посмотрит в глобальной
# области видимости (допустим она там есть.)
# Локальные переменные недоступны глобальным, а наоборот глобальные доступны локальным.
# Это например как файл с кодом - все переменные (объекты) в ней относятся к глобальной видимости. А переменные внутри
# функций относятся к локальной видимости функции. Поэтому мы не можем глобально получить доступ к локальным переменным
# функции.
# Есть только глобальная область видимости и область видимости функции.

# Цепочка областей видимости в пайтон
# a = 5  # 3. Не найдя в my_fn(), уходит в глобальную область видимости


# def my_fn():  # 2. Не найдя в функции inner_fn(), он ищет в my_fn()
#     def inner_fn():
#         print(a)  # 1. Пайтон сначала идет переменную a внутри inner_fn()
#     inner_fn()


# my_fn()


# 96. Жизненный цикл переменных.
# Если после выполнения функции, в теле функции мы не возвращаем ничего, то все переменные из неё удаляются.
# Функция очищается. В обратном случае говорят, функция замыкается (если возвращаем переменную)


# 97. Ключевое слово global в функциях
# С помощью него можно объявлять переменные в глобальной области видимости.
# def my_fn():
#     global a  # тут переменная объявляется.
#     a = 10  # переменная создаётся на этой строке.


# my_fn()
# print(a)
# Если изначально была создана переменная со значением, и в функции мы её можем переписать если объявим глобально
# И притом вызовем потом эту функцию. Если не вызовем, переменная не перезапишется.
# Не рекомендуется изменять в функции глобальные переменные (только если это действительно надо)


# 98. Практика - глобальные и локальные переменные.
# c = 5


# def my_fn(a, b):
#     print(a, b)
#     print(c)  # локальная область функции увидит глобальную переменную


# a = 'abc'
# b = 'xyz'
# my_fn(a, b)
# print(dir())


# 99. Операторы пайтон
# Оператор присвоения a = 10  Равно это оператор (бинарный), а и 10 это операнды.
# Арифметические операторы: +, 0, *, / и т.д.
# Операторы сравнения: == (равно), !=(не равно), <, >  Результат будет булево значение
# Логические: not, and, or  Часто используются в условных инструкциях типа if, else
# Текстовые операторы: not, and, or, is, is not, in (есть ли определенный элемент в определенной последоват-ти), not in

# a = 10
# b = a
# c = a + b
# print(a == b)
# print(c is a)  # True, потому что объект один


# 100. Операторы и магические методы
# a = [1, 2]
# b = [1, 2]
# print(a == b)
# print(a.__eq__(b))  # Класс определяется исходя из какого класса был создан объект a
# print(a is b)  # False потому что списки это 2 разных объекта
# print(a.__eq__)
# print(id(a))
# print(hex(id(a)))  # hex переводит объект в формат base16


# 101. Функция dir
# print(dir(list))


# 102. Бинарные и унарные операторы
# Унарные операторы состоят из одного оператора и одного операнда
# - my_number  # поменять знак с плюса на минус например
# + my_number  # чтобы явно показать, что мы работаем с числом и это позитивное число. Можно конвертировать логическое
# значение в целое число
# not is_activated  # оператор отрицания. Можно использовать двойное отрицание not not

# my_num = 10
# print(+ my_num)
# print(not my_num)  # Отрицание правдивого значения это False. Отрицание ложного значения (0) это True
# my_bool = True
# print(+ my_bool)  # Вот тут конвертировали бул в целое число

# Бинарные операторы
# +, =, +=, ==, and
# Инфиксная (ударение на первую букву) запись это для бинарных операторов, когда оператор между двумя операндами.


# 103. Операторы in, not in
# Для проверки присутствия элемента в последовательности
# my_car = {
#     'brand': 'Chevrolet',
#     'Price': '1 mln',
# }
# print('brand' in my_car)  # True
# print('is_available' in my_car)  # False
# print('is_available' not in my_car)  # True


# 104. Приоритетность операторов
# Лучше всего определять самому скобками (a + b) / (c - d)
# Приоритетность можно найти в нете.


# 105. Задача - операторы
# 1. Создайте две переменные и присвойте им одинаковые последовательности типа set. При этом не копируйте одну переменную
# в другую
# 2. Выведите в терминал результат сравнения двух созданных объектов, объясните результат. @ True у них одинаковый набор данных.
# 3. Сравните 2 объекта, используя оператор is, объясните результат. @ False, это разные объекты.
# Перепишите выражение с оператором is по-другому, с использованием оператора сравнения.  @ Невозможно.
# 4. Проверьте, есть ли определенные элементы в наборе, используя оператор in. Поэкспериментировать с not in.
# Результаты выводить в терминал
# first_set = {1, 2, 3}
# second_set = {1, 2, 3}
# print(first_set == second_set)
# print(first_set is second_set)
# print(id(first_set))
# print(id(second_set))
# print(1 in first_set)
# print(1 not in first_set)
# print(4 in first_set)


# 106. Ложные значения
# Это те значения, которые при приведении к логическому типу (bool) даёт False.
# Примеры ложных значений:
# print(bool(0))
# print(bool(0.0))
# print(bool(0j))
# print(bool(None))
# # Пустые последовательности также ложные (в других языках программирования это не так)
# print(bool({}))
# print(bool([]))
# print(bool(()))
# print(bool(set()))
# print(bool(range(0)))
# print(bool(('')))
# print(not {})  # т.е. not False
# print(not not {})  # True

# Ложные значения в условных инструкциях if
# my_list = [1, 2]
# if len(my_list) > 0:  # обычно так не пишут, а пишут так как ниже.
#     print('List has elements')

# if my_list:  # Эта запись идентична предыдущей с >. Пайтон сам выполняет конвертацию этого выражения в логическое значение
#     print('List has elements')


# 107. Логические операторы
# not - всегда возвращает логическое значение. Унарный префиксный оператор. Чаще всего используется в условных инструкциях if
# and, or - возвращают значение одного из операндов


# 108. Операторы короткого замыкания (short circuit) or и and
# and - инфиксный бинарный оператор
# Выражение 1 and Выражение 2. Если выражение 1 ложно, то выражение 2 игнорируется и возвращается выражение 1.
# Если выражение 1 правдиво, то and вернёт выражение 2 независимо от того, ложно оно или правдиво.

# Оператор or.
# Выражение 1 or выражение 2. Если выражение 1 истино, то выражение 2 игнорируется, возвращается результат выражения 1.
# Результатом всего выражения (1 or 2) будет выражение 1.
# Если выражение 2 ложно, то возвращается результат выражения 2 независимо от того, ложно оно или истинно.
# a and b or c and d  В этом случае лучше явно указывать в скобках что за чем идёт


# 109. Практика - логические операторы.
# my_list = [1, 2]
# other_list = ['a', 'b']
# print(my_list or other_list)
# # Вернёт True, т.к. до or это логическое значение
# print(len(my_list) > 0 or other_list)
# print(len(my_list) < 0 or other_list[0])
# # В качестве второго операнда функция. Результат вызова функции это выражение.
# my_list and print('my list is not empty')

# Задача - сделать 2 одинаковых словаря и используя оператор and вывести в терминал dictionaries are equal, если
# они одинаковые (словари, а не объекты)
# dict_one = {'name': 'Nick', 'old': 'No'}
# dict_two = {'old': 'No', 'name': 'Nick'}
# dict_one == dict_two and print('Dictionaries are equal')
# print(dict_one == dict_two)


# 110. Оператор распаковки словаря **
# button = {
#     'width': 200,
#     'Text': 'Buy'
# }
# red_button = {
#     # Распаковываем предыдущий словарь сюда. Если ниже распаковать (и в нём цвет будет), то первый словарь перезапишет цвет.
#     **button,
#     'Color': 'Red'
# }
# print(button)
# print(red_button)


# 111. Объединение словарей **
# button = {
#     'width': 200,
#     'Text': 'Buy'
# }
# red_button = {
#     'Color': 'Red'
# }
# new_button = {
#     **button,
#     **red_button
# }
# new_button = button | red_button  # Или вот так можно сделать
# print(new_button)
# При этом исходные словари не меняются.

# Задание объединить 3 разных словаря
# first_dict = {'color': 'Grey'}
# second_dict = {'name': 'Button'}
# third_dict = {'width': '20'}
# sum_dict = first_dict | second_dict | third_dict
# print(sum_dict)


# 112. Инструкция del
# С помощью неё можно удалять элементы из последовательностей: из словаря по названию ключа, из списка по индексу.
# del это инструкция, как и return.
# my_dict = {'a': True, 'b': 10}
# del my_dict['a']  # del вызывает __delitem
# my_dict.__delitem__('b')  # __delitem равносильно del
# print(my_dict)
# print(del my_dict['a'])  # Вот так можно проверить, что del это инструкция. Будет ошибка. Нужно писать на
# отдельной строке кода.


# 113. Соединение строк
# 'Hello ' + 'Python'
# hello = 'Hello'
# world = 'World'
# greeting = 'Hello' + ' ' + 'World'
# print(greeting)


# 114. Форматирование строк в f-strtings
# Если надо объединить строку, где есть 3-4 разных переменных, то оператор + не очень удобен.
# hello = 'Hello'
# world = 'World'
# # Вот так. В {} могут быть любые выражения, даже вызов функции.
# greeting = f'{hello} {world}'
# print(greeting)


# 115. Практика - объединение строк с помощью +
# my_name = 'Nick'
# my_hobby = 'running'
# time = 8
# expression = my_name + ' likes ' + my_hobby + ' at ' + str(time) + "o'clock"
# expression = f'{my_name} likes {my_hobby} at {time} o\'clock'
# expression = f'{my_name} Likes {my_hobby.capitalize()} At {time} O\'clock'
# print(expression)


# 116. Практика f-strings см выше.
# my_name = 'Nick'
# qty = 10.5
# list = [10, - 15]
# check = True
# info = f'{my_name} wants {qty} or {list} girls, is it {check}?'
# print(info)


# 117. Лямбда функции.
# Они всегда анонимные. После : должно быть только выражение, не инструкция.
# mult = lambda a, b: a * b  # После выполенния кода синтаксис лямбда ф-и будет заменён на обычную. Согласно РЕР-8 не
# следует присваивать переменным лямбда функции.
# def mult(a, b): return a * b


# print(mult(10, 5))

# Если мы из одной функции возвращаем другую функцию, которая состоит из одного выражения, есть смысл
# использовать лямбда функцию
# Пример:
# def greeting(greet):
#     return lambda name: f'{greet} {name}!'


# # Вот тут мы вызвали функцию greeting. Она передала 'good morning' в лямбду в {greet} и завершила свою работу.
# # Тут переменная morning_greeting стала функцией greeting.
# morning_greeting = greeting('Good morning')
# # Вызывая функцию morning_greeting, она передала переменную 'Nick' во вторую половину лямбды, т.к. первая уже
# # завершилась с окончанием функции greeting.
# print(morning_greeting('Nick'))
# evening_greeting = greeting('Good evening')
# print(evening_greeting('Nick'))


# 118. Практика - лямбда функции (см. пример выше)
# А также можно заменить лямбда на обычную функцию
# def greeting(greet):
#     def info(name):
#         return f'{greet}, {name}!'
#     return info


# morning_greeting = greeting('Good morning')
# print(morning_greeting('Nick'))
# evening_greeting = greeting('Good evening')
# print(evening_greeting('Nick'))
# nigga_greeting = greeting('Zdarova')
# print(nigga_greeting('niga'))


# 119. Обработка ошибок Try/Except (очень важная тема! обработчик делает программы пайтон более стабильными)
# try:
#     print(10 / 0)
#     # print(10 + '2')
#     # ZeroDivisionError это функция конструктор. Из неё можно также создавать объекты класса этих ошибок
# except ZeroDivisionError:
#     print('Durak na nol\' ne deli')
#     print(ZeroDivisionError)  # Вот так класс этой ошибки можно посмотреть
# except TypeError:
#     print('Tak nelzya')


# 120. Получение информации об ошибке.
# try:
#     print(10 / 0)
# except ZeroDivisionError as e:  # Чтобы вручную не писать текст ошибки, можно сделать так
#     print(type(e))  # Покажет класс ошибки
#     print(dir(e))
#     # Print выводит в терминал текстовую версию этого объекта, с помощью .__str__ Т.е. фактически происходит конвертация
#     # объекта в строку.
#     print(e)
#     print(e.__str__())  # Вот так


# 121. Разные типы ошибок в разных блоках except (см. 119)


# 122. Блоки else и finally в обработке ошибок
# try:
#     print(10 / 2)
# except ZeroDivisionError as e:
#     print('Fuck you')
# else:  # Выполнится, если ошибки нет и except не отработает
#     print('There is no mistakes')
# finally:  # Выполнится независимо от того, отработал except или else
#     print('continue')


# 123. Отсутствие типа ошибки и класс Exception
# Если мы не знаем, какие ошибки могут возникнуть, можно сделать вот так:
# try:
#     print(10 / 0)
# except:  # Вот так не нужно делать, потому что непонятно, что за ошибка.
#     print('Some mistake occured')
# или так:
# try:
#     print(10 / 0)
# # Вот так самостоятельно будет класс Exception определять ошибку. Сохраняем ошибку в переменную.
# except Exception as e:
#     # Проверяем, является ли е объектом класса ZeroDivisionError
#     print(isinstance(e, ZeroDivisionError))
#     # Exception это родительский класс для всех ошибок.
#     print(isinstance(e, Exception))
#     # Класс object это корневой класс для ВСЕХ объектов в пайтон.
#     print(isinstance(e, object))
#     print(e)


# 124. Создание ошибок
# def divide_nums(a, b):
#     if b == 0:
#         # Можем отнести ошибку к любому классу.
#         raise ValueError('Second argument can\'t be 0')
#     return a / b
# Можно напечатать raise Error, появится список доступных ошибок.


# try:
#     divide_nums(10, 0)
# Вот это исключение уже лишнее, мы зашили ошибку выше.
# except ZeroDivisionError as e:
#     print(e)
# except ValueError as e:
#     print(e)
# finally:
#     print('continue')

# Все крайние случаи (side cases) и генерации ошибок обрабатывать в функции


# 125. Задача - обработка ошибок
# 1. создать функцию image_info с одним параметром типа dict
# 2. Функция ожидает словарь, в котором должно быть как минимум 2 ключа (в исходном словаре их будет больше)
# image_id и image_title
# 3. Функция должна возвращать строку такого вида: "Image 'my cat' has id 5136". My cat и id 5136 будут зависеть от значений
# ключей image_id и image_title (Динамическим образом формируем строку).
# 4. Если хотя бы одного из этих ключей нет в словаре, функция должна генерировать ошибку TypeError (текст может быть
# любым, но должно быть понятно, что функция ожидает от вас - если нет ключа image_id, то так и написать)
# 5. Вызвать функцию и корректно отработать ошибку в случае возникновения. Текст возникшей ошибки вывести в терминал.
# 6. Один раз вызывать функцию, где оба ключа в словаре есть, а другой где нет одного или обоих ключей.
# Мы добавляем проверку внутри функции, так, чтобы её нельзя было вызвать со словарём,  в котором нет image_id и image_title.

# Сделал вот так. Попробуй: если при получении ключа image_id в словаре ничего не будет, вызови ошибку типа TypeError.
# Если другого ключа не будет, вызови другую ошибку, такого же типа TypeError. Если ошибки не будет, присвой переменной post
# динамическую строку и выведи её в терминал. Если ошибка всё-таки вылезла, исключение для неё - не пиши ошибку, а выведи
# текст ошибки в терминал.

# def image_info(a_dict):
#     try:
#         if image_dict.get('image_id') == None:
#             raise TypeError('There is no image_id in dictionary')
#         if image_dict.get('image_title') == None:
#             raise TypeError('There is no image_title in dictionary')
#         else:
#             post = f'"Image {image_dict['image_title']
#                              } has id {image_dict['image_id']}"'
#             print(post)
#     except TypeError as e:
#         print(e)


# image_dict = {
#     'image_id': 5136,
#     'image_title': '\'my cat\'',
#     'image_width': 400,
#     'image_height': 600,
# }
# image_info(image_dict)


# 126. Распаковка списков и кортежей.
# Распаковка - это извлечение значений и присвоение их переменным. При этом первоначальный объект не изменяется.
# my_fruits = ['apple', 'banana', 'lime']
# # Вот так, через запятую присвоятся к этим переменным элементы списка или кортежа. Порядок важен.
# my_apple, my_banana, my_lime = my_fruits
# print(my_apple)

# С помощью оператора * можно объединить элементы списка в другой список, вот так:
# my_fruits = ['apple', 'banana', 'lime']
# my_apple, *rest_fruits = my_fruits
# print(my_apple)
# print(rest_fruits)  # Вот так banana и lime объединяться в список rest_fruits()

# А словарь так не получится распаковать, как списки и кортежи - будут только ключи.
# my_name, my_comments = user_profile
# print(my_comments, my_name)

# 127. Распаковка словаря в именованные аргументы (аргументы с ключевыми словами).
# user_profile = {
#     'name': 'Nick',
#     'comments_qty': 23,
# }


# def user_info(name, comments_qty=0):
#     if not comments_qty:  # Вот так можно сказать - если нет ключа такого в словаре, делай так-то. При этом значение
#         # по умолчанию надо 0 поставить, а то будет ошибка.
#         return f'{name} has no comments'
#     return f'{name} has {comments_qty} comments'


# # Распаковываем в функцию словарь. Ключи словаря становятся именованными аргументами.
# print(user_info(**user_profile))
# # Или можно передать в функцию позиционные аргументы из словаря
# print(user_info(user_profile['name'], user_profile['comments_qty']))
# # Или можно передать в функцию аргументы с ключевыми словами из словаря
# print(user_info(name=user_profile['name'],
#       comments_qty=user_profile['comments_qty']))


# 128. Распаковка списка в позиционные аргументы.
# user_data = ['Nick', 23]


# def user_info(name, comments_qty=0):
#     if not comments_qty:
#         return f'{name} has no comments'
#     return f'{name} has {comments_qty} comments'


# print(user_info(*user_data))  # Вот таким образом
# # Или позиционные аргументы через обращение к индексу
# print(user_info(user_data[0], user_data[1]))
# # Или именованные аргументы
# print(user_info(name=user_data[0], comments_qty=user_data[1]))
# # Или заранее распаковать список и передать отдельные переменные в print
# my_name, my_comments = user_data
# print(user_info(my_name, my_comments))


# Задание:
# 1. Создать список словарей, и в нём будет 3 словаря. Далее с помощью оператора распаковки списков создать 3
# переменных, каждая из которых будет содержать 1 из словарей. Далее создать функцию, которая будет принимать 2 аргумента.
# И в вызове функции распаковывать словарь. Вызвать функцию 3 раза, т.к. в оригинальном списке было 3 словаря. У каждого из
# этих словарей должно быть по 2 ключа.
# list_of_dict = [{'name': 'Nick'}, {'age': 36}, {"is_strong": True}]
# my_name, my_age, my_power = list_of_dict


# def my_func(a, b):
#     print(a, b)


# my_func(my_name, my_age)
# my_func(my_name, my_power)
# my_func(my_age, my_power)


# 129. Условные инструкции
# if если. После if должно быть выражение.
# else если условие if не выполняется, то это
# elif если условие if не выполняется, то это n раз, пока не выполнится условие. Если ничего не выполнится, то else
# ещё есть тернарный оператор. Т.к. это оператор, результатом его будет выражение, которое можно присвоить переменной
# или использовать в вызове функции.


# 130. if
# если выражение правдиво, то блок кода выполняется. Если нет - не выполняется.
# my_number = 25
# if my_number > 0:
#     print(my_number, 'is positive number')

# person = {'age': 36}

# if not person.get('age'):  # Если ключ age в словаре остутствует, то...
#     print('Age is absent')
# Инструкция отработает если ключа нет, или его значение ложно (0)

# Или вот так. Можно длинную строку в круглые скобки поместить и разбить на несколько отдельных строк.
# num_one = 10
# num_two = 5.3
# if (num_one > 0 and
#     num_two > 0 and
#     isinstance(num_one, int) and
#     isinstance(num_two, float)):
#     print('Both numbers are int and positive')


# 131. Инструкция if else
# my_number = 21.5
# if type(my_number) is int:
#     print('my_number is integer')
# else:
#     print('my_number is float')

# или вот ещё пример
# my_phone = {'price': 200}
# if my_phone.get('brand'):  # Тут автоматическая конвертация в пайтон в true или false
#     print('my phone\'s brand is', my_phone['brand'])
# else:
#     print('my phone has no brand')


# 132. Инструкция if elif
# my_number = 0
# if my_number > 0:
#     print('my number is positive number')
# elif my_number < 0:
#     print('my number is negative number')
# else:
#     print('my number is zero')
# Можно вместо elif использовать просто if, это равнозначно, но нет цепочки условий.


# 133. Использование if в функциях
# В функциях лучше использовать блоки return, а не elif и else.
# def nums_info(a, b):
#     if type(a) is not int or type(b) is not int:
#         return 'One of arguments in not integer'
#     if a >= b:  # Если условие выше не выполняется и оба аргумента будет int, то будет это условие.
#         return f'{a} more or equal to {b}'
#     return f'{a} less than {b}'


# print(nums_info(True, 10))
# print(nums_info(5, 10))
# print(nums_info(14, 10))

# Или вот так (но тогда не явно видно, что происходит в функции)

# def nums_info(a, b):
#     if type(a) is not int or type(b) is not int:
#         info = 'One of arguments in not integer'
#     elif a >= b:
#         info = f'{a} more or equal to {b}'
#     else:
#         info = f'{a} less than {b}'
#     return info


# print(nums_info(True, 10))


# 134. Задача - условные функции
# 1. Создать функцию route_info, которой будет передаваться словарь (один параметр)
# 2. Если в словаре, который передаётся в функцию, есть ключ distance и его значение - целое число, верните строку
# "Distance to your destination is <distance> (значение ключа distance)"
# 3. Иначе, если в словаре есть ключи speed и time, верните строку "Distance to your destination is <speed*time>"
# На этом же шаге добавить проверку того, что speed и time это целые числа.
# 4. Иначе верните строку "No distance info is available"
# 5. Вызвать функцию несколько раз с разными аргументами (3 раза. 1й - будет дистанция, 2й - будет скорость и время,
# 3й не будет ничего)
# 6. Сделать функции и с словом return и c инструкциями elif.


# def route_info(dict):
#     if (type(dict.get('distance')) is int and not not
#             dict.get('distance')):
#         return f'Distance to your destination is {dict['distance']}'
#     elif (type(dict.get('speed')) is int and
#             type(dict.get('time')) is int and (not not
#                                                dict.get('speed') or not not
#                                                dict.get('time'))):
#         return f'Distance to your destination is {dict['speed']*dict['time']}'
#     else:
#         return 'No distance info is available'


# distance_dict = {'distance': 500}
# speed_dict = {
#     'speed': 60,
#     'time': 3
# }
# print(route_info(distance_dict))
# print(route_info(speed_dict))


# 135. Тернарный оператор.
# У него 3 операнда.
# выражение_1 if условие else выражение_2. Если условие правдиво, возвращается выражение_1, иначе - выражение_2
# Выражения могут быть функциями. Результат можно присвоить переменной, если надо, или другому выражению.
# my_num = 21.5
# if type(my_num) is int:
#     print('my number is integer')
# else:
#     print('my num is not an integer')

# # Или вот так с помощью тернарного оператора можно записать.
# print('my num is integer') if type(
#     my_num) is int else print('my_num is not an integer')

# ещё пример функции:
# send_img(img) if img.get['is_processed'] else send_and_process_img(img)

# ещё пример функции:
# product_qty = 10
# print('in stock' if product_qty > 0 else 'out of stock')


# 136. Практика - тернарный оператор
# my_img = ('1024', '768')
# print(f'{my_img[0]}x{my_img[1]}') if len(
#     my_img) == 2 else print('formatting is incorrect')
# # или вот так можно написать:
# my_img = ('1024', '768')
# info = f'{my_img[0]}x{my_img[1]}' if len(
#     my_img) == 2 else 'formatting is incorrect'
# print(info)


# 137. Задачи - тернарный оператор
# 1. Переписать задачу выше, используя if else
# my_img = ('1024', '768', True)
# if len(my_img) == 2:
#     print(f'{my_img[0]}x{my_img[1]}')
# else:
#     print('formatting is incorrect')

# 2. Сделать так, чтобы с помощью тернарного оператора можно было проверить длину строки. Например, если длина
# строки больше 79 символов, то выводим в терминал string is long, иначе текст string is short.
# my_str = 'I want to be a successfull programmer'
# print('string is long') if len(my_str) > 79 else print('string is short')


# 138. Циклы
# Используются для перебора элементов последовательностей dict, list, tuple, set, range, str


# 139. Циклы for in
# For элемент in последовательность
# my_list = [True, 10.4, 'abc', {}]  # Списки
# for elem in my_list:
#     print(elem)

# my_tuple = ('1920x1080', True, 27)  # Кортежи
# for elem in my_tuple:
#     print(elem)

# my_dict = {
#     'a': 10,
#     'b': 'ok',
#     'c': True,
# }
# for elem in my_dict:
#     print(elem, my_dict[elem])  # Если без my_dict[elem], будут только ключи.


# 140. Практика - цикл for in
# for el in [1, True, 'abc']:
#     print(type(el))  # Выведет класс каждого из элементов списка
#     print(el)

# # Переменная el создана в глобальной зоне видимости. Поэтому не нужно использовать переменную, которую ранее брали
# print(el)
# print(dir())  # Вот так проверяем

# for key in {'id': 1523}:
#     print(type(key))  # В словаре все ключи это str
#     print(key)

# my_dict = {'id': 1523}
# for key in my_dict:
#     print(type(my_dict[key]))
#     print(my_dict[key])


# 141. Итерация по ключам со значениями в словаре. Через метод .items, который возвращает тип объекта dict_items, который
# является кортежем с парой ключ-значение.
# my_dict = {'id': 1523, 'is_long': True}
# for key in my_dict.items():  # key здесь будет кортежем
#     print(key)  # Сразу выводятся 2 кортежа
# print(type(my_dict.items()))

# my_dict = {'id': 1523, 'is_long': True}
# for any in my_dict.items():
#     # Сделали распаковку кортежа в переменные key, value (могут быть любыми, часто сокращают k, v)
#     key, value = any
#     print(key, value)

# # А можно сразу распаковку сделать key и value, вот так:
# my_dict = {'id': 1523, 'is_long': True}
# for key, value in my_dict.items():
#     print(key, value)
# # Так часто делают при итерации словарей, надо запомнить.


# 142. Цикл for in для наборов
# Наборы это неупорядоченная последовательность, порядок при итерациях будет хаотичный.
# video_ids = {1423, 1265, 1938, 3592}
# for el in video_ids:
#     print(el)

# Циклы для строк
# my_str = 'Nickolay'
# for el in my_str:
#     print(el)

# Циклы для диапазонов range. Если нужно повторить действие n раз.
# for num in range(10):
#     print(num)

# for odd_num in range(3, 10, 2):  # начало, конеч, шаг
#     print(odd_num)


# 143. Задачи - цикл for in
# Задача 1:
# 1. Создать функцию dict_to_list, которая будет конвертировать словарь в список кортежей. Вернуть надо будет список
# кортежей - значение типа list
# 2. Функция должна принимать словарь, а возвращать список кортежей, в каждом кортеже должны быть пары (key, value)
# из словаря.
# 3. Если значение ключа это целое число, то его нужно умножить на 2 перед добавлением в кортеж.
# def dict_to_list(dic):
# return [(k, v * 2) if isinstance(v, int) else (k, v) for k, v in dic.items()]


# my_dict = {
#     'my_name': 'Nick',
#     'my_age': 18,
#     'my_hobby': True,
# }

# print(dict_to_list(my_dict))
# print(type(dict_to_list(my_dict)))


# Задача 2:
# 1. Создать функцию filter_list, которая будет фильтровать список.
# 2. У функции должно быть 2 параметра - список и тип значения. Т.е. функция будет вызываться с 2мя аргументами.
# Первый - это список, а второй - определённый тип (либо int, либо str)
# 3. Функция должна вернуть новый список, в котором останутся только значения того типа, который был передан в вызове
# функции вторым аргументом. Т.е. задача функции - принять список со значениями разных типов, и отфильтровать этот
# список, оставив только те значения, которые имеют определенный тип.
# 4. Функцию можно будет вызывать например так: filter_list([35, True, 'abc', 10], int) и получить [35, 10]. Т.е.
# здесь удалены все не int.
# def filter_list(list, type):
#     new_list = []
#     for el in list:
#         if isinstance(el, type):
#             new_list.append(el)
#     return new_list


# print(filter_list([35, 4.1, 'abc', 10, 145, [10, 4, 'no']], int))


# 144. Встроенная функция filter
# def filter_list(list_to_filter, elem_type):
#     def filter_type(elem):
#         return isinstance(elem, elem_type)
#         # return type(elem) is elem_type  # или вот так.
#     return list(filter(filter_type, list_to_filter))
#     # Или вот так, вместо всего тела функции
#     # return list(filter(lambda elem: type(elem) is elem_type, list_to_filter))


# res = filter_list([1, 10, 'abv', 4.3], int)
# print(res)

# print(isinstance(True, bool))
# print(isinstance(True, int))  # bool является подклассом int
# print(int.__subclasses__())  # Вот так можно проверить.


# 145. Цикл while
# Выполняется до тех пор, пока не будет выполнено условие
# i = 10
# while i <= 50:
#     print(i)
#     i += 10

# while True:
#     answer = input('Enter yes or no: ')
#     if answer == 'no':
#         break


# 146. Использование continue в циклах
# Означает переход к следующей итерации, если условие не было выполнено.
# import random
# random_num = random.randint(1, 5)
# while True:
#     num = int(input('Enter some num from 1 to 5: '))
#     if num != random_num:
#         continue
#     else:
#         print('Correct!', random_num)
#         break


# 147. Задача - цикл while
# 1. Создать цикл, в котором попросить пользователя ввести в терминале 2 числа (2 просьбы)
# 2. Ввести в терминал результат деления первого числа на второе
# 3. После этого спросить пользователя, хочет ли он продолжать yes/no
# 4. Если ответ no, нужно выйти из цикла
# 5. Иначе нужно повторить всё сначала.
# 6. Ввести проверку, является ли второе число нулём. Если да - сгенерировать ошибку.
# while True:
#     num_1 = float(input('please enter first number: '))
#     num_2 = float(input('please enter second number: '))
#     if num_2 == 0:
#         print('Cannot divide by zero')
#     else:
#         print(num_1 / num_2)

#     a = input('Do you want to continue? ')
#     print(a)
#     if a == 'yes':
#         continue
#     else:
#         break


# 148. Сокращённый цикл for in
# Сокращённый for in используется для создания новых последовательностей на основе существующих (list, dict, tuple, set)
# Выаражение for элемент in последовательность if условие. Условие опционально.
# Вот это обычная запись:
# all_nums = [-1, 3, -10, -7, 6]
# absolute_nums = []
# for num in all_nums:
#     absolute_nums.append(abs(num))
# print(all_nums)
# print(absolute_nums)
# Эти строки можно записать коротко:
# all_nums = [-1, 3, -10, -7, 6]
# abs_nums = [abs(num) for num in all_nums]
# print(abs_nums)

# Ещё пример:
# all_nums = [-1, 3, -10, -7, 6]
# positive_nums = []
# for nums in all_nums:
#     if nums > 0:
#         positive_nums.append(nums)
# print(positive_nums)
# # А вот это сокрещённая запись:
# all_nums = [-1, 3, -10, -7, 6]
# positive_nums = [num for num in all_nums if num > 0]
# print(positive_nums)


# 149. Примеры с сокращённым циклом for in
# Формирование нового набора в обычном for in
# my_set = {1, 10, 15}
# new_set = set()
# for val in my_set:
#     new_set.add(val * val)
# print(my_set)
# print(new_set)
# # А вот это сокращённая запись:
# my_set = {1, 10, 15}
# new_set = {val * val for val in my_set}
# print(new_set)

# Для словарей обычная запись for in:
# my_dict = {
#     'a': 5,
#     'b': 7,
#     'c': 10,
# }
# new_dict = {}
# for key, value in my_dict.items():
#     new_dict[key] = value * 10
# print(new_dict)
# # А сокращённая запись вот так будет:
# my_dict = {
#     'a': 5,
#     'b': 7,
#     'c': 10,
# }
# new_dict = {k: v * 10 for k, v in my_dict.items()}
# print(new_dict)


# 150. Практика - сокращённый цикл for in
# my_dict = {
#     'a': 5,
#     'b': 7,
#     'c': 10,
# }
# # А если сделать без ключа, просто значение, выйдет набор set.
# new_dict = {v * 10 for k, v in my_dict.items()}
# print(new_dict)
# new_list = [v * 10 for k, v in my_dict.items()]
# print(new_list)  # Можно в список также перевести словарь.

# А можно сделать из списка словарь
# my_scores = [5, 10, 3]
# my_dict = {index: elem * 2 for index, elem in enumerate(my_scores)}
# print(my_dict)


# 151. Задачи - сокращённый цикл for in
# list comprehensions, dictionary comprehensions, set comprehensions.
# Задача 1:
# 1. Создать словарь с несколькими ключами, значения которых должны быть типа str
# 2. Создать новый словарь на основании существующего, в котором значения всех ключей будут в верхнем регистре.
# 3. Результирующий словарь вывести в терминал.
# Сделать всё это нужно с помощью короткого цикла for in (можно сначала сделать с помощью обычного цикла)
# Полная запись:
# my_dict = {
#     'name': 'Nick',
#     'age': 'no',
#     'is_ok': 'How do you think',
# }
# new_dict = {}
# for k, v in my_dict.items():
#     new_dict[k] = v.upper()
# print(new_dict)

# Сокращённая запись:
# my_dict = {
#     'name': 'Nick',
#     'age': 'no',
#     'is_ok': 'How do you think',
# }
# new_dict = {k: v.upper() for k, v in my_dict.items()}
# print(new_dict)


# Задача 2:
# 1. Создать список с элементами типа str
# 2. Из этого списка создать новый список, в котором останутся только строки, длина которых больше 3.
# 3. Результирующий список вывести в терминал.
# Полная запись:
# my_list = ['hi', 'what\'s your name?', 'wazap']
# new_list = []
# for el in my_list:
#     if len(el) > 3:
#         new_list.append(el)
# print(new_list)
# Сокращённая запись:
# new_list = [num for num in my_list if len(num) > 3]
# print(new_list)


# 152. Генераторы в сокрещённом for in
# nums = (3, 6, 9)
# # Вот тут получится не кортеж, а объект класса генератор.
# squares = (num * num for num in nums)
# print(squares)
# print(type(squares))

# Генератор это последовательность элементов, по которой можно выполнять итерацию
# more_nums = (num * num for num in range(6))
# for n in more_nums:
#     print(n)

# Можно преобразовывать генераторы в списки, или котрежи.
# nums = [3, 5, 10]
# gen = (n * n for n in nums)
# gen_list = list(gen)
# gen_tuple = tuple(gen)
# print(gen_list)
# print(type(gen))
# print(type(gen_list))
# print(type(gen_tuple))

# Генераторы хороши малым размером.
# from sys import getsizeof
# gen_size = (num * num for num in range(10000))
# print(getsizeof(gen_size))  # 200 - размер в байтах генератора в памяти
# print(type(gen_size))
# list_size = [num * num for num in range(10000)]
# print(getsizeof(list_size))  # 85176 - размер в байтах списка в памяти
# print(type(list_size))
# Если нужно работать с большими данными, лучше создавать генератор, далее по нему делать итерацию и дальше
# обрабатывать нужные элементы этой итерации.


# 153. Практика - генераторы
# from sys import getsizeof
# gen_size = (num * num for num in range(10000))
# for el in gen_size:
#     print(el)
#     if el == 100:
#         break
# print(getsizeof(gen_size))
# Будет ошибка. Нельзя получать доступ к элементам в генераторе по индексу.
# print(gen_size.get[3])


# 154. Объекты и классы в пайтон.
# Классы это шаблоны для объектов. На основании шаблонов создаются экземпляры объектов. Экземпляры могут иметь
# собственные атрибуты, которые можно изменять независимо от других экземпляров. Изменять атрибуты можно только
# обращаясь к конкретному экземпляру. Экземпляры наследуют атрибуты классов.
# Вот так можно создать класс:
# class Car:
#     # self это указание на определённый экземпляр класса Car. Move и stop будут вызываться для определённого
#     # экземпляра класса Car.
#     def move(self):
#         print('Car is moving')

#     def stop(self):
#         print('Car has stopped')


# my_car = Car()
# print(type(my_car))  # Класс создался в главном модуле main.
# print(isinstance(my_car, Car))
# my_car.move()  # С помощью . можно получить доступ к атрибуту класса.
# my_car.stop()
# Мы не указываем никакие параметры для методов, потому что пайтон автоматически подставляет объект, для
# которого вызывается этот метод. И этот объект попадает в функцию, где self написано.


# 155. Практика - создание экземпляров класса.
# class Car:
#     def move(self):
#         print('Car is moving')

#     def stop(self):
#         print('Car has stopped')


# my_car = Car()
# print(dir(my_car))
# # будет {}. Это значит, что собственных атрибутов у my_car нет. И все атрибуты , в частности move и stop
# # наследуются из класса Car.
# print(my_car.__dict__)
# second_car = Car()
# print(my_car == second_car)
# Car.move(my_car)  # А можно и так сделать.
# Car.stop(my_car)


# 156. Магический метод классов __init__
# # # __init__ это функция-конструктор, которая вызывается при создании новых экземпляров класса
# # # Когда мы создаём экземпляр класса, например my_car = Car(), вызывается как раз эта функция.
# class Comment:
# self здесь указывает на определённый экземпляр класса Comment. При создании объекта, он передаётся
# в функцию первым параметром. А второй параметр задаём мы в аргументе вызова функции.
# __init__ это собственные атрибуты экземпляра, а остальное - наследуется всеми экземплярами класса.
# Значение по-умолчанию делает параметр опциональным.
# def __init__(self, text, initial_votes_qty=0):
#     self.text = text  # Здесь мы создаём атрибут text для объекта self и присваиваем ему значение параметра text
#     # А здесь для атрибута votes_qty присваиваем значение initial_votes_qty.
#     self.votes_qty = initial_votes_qty

# def upvote(self, qty):
#     self.votes_qty += qty  # Здесь мы увеличиваем на n значение собственного атрибута
#     # При этом метод upvote не собственный метод экземпляров класса, а метод класса Comment

# def reset_votes_qty(self):
#     self.votes_qty = 0


# # Когда мы вот такое пишем, пайтон автоматически создаёт объект класса, который попадает в параметр self функции.
# # И после этого, аргумент, который мы указали в скобках - он идёт вторым параметром в функцию.
# first_comment = Comment('Hello', 5)

# # Проверяем собственные методы экземпляра first_comment класса Comment. Выводит словарь, где ключ - метод, а
# # значение - переданные аргументы (или параметры по умолчанию)
# print(first_comment.__dict__)
# print(first_comment)
# print(first_comment.votes_qty)
# print(type(first_comment))
# print(dir(first_comment))  # доступные атрибуты для объекта.
# print(first_comment.text)
# print(first_comment.votes_qty)
# # Тут мы назначаем новый собственный метод upvote именно для объекта first_comment. Для объекта second_comment
# # этот метод не собственный
# # first_comment.upvote = 10
# print(first_comment.__dict__)  # убеждаемся в этом.
# # Вот тут будет ошибка, потому что мы назначили новый собственный атрибут upvote и пайтон сначала выполняет
# # собственные методы классов, а потом на уровне классов. При этом атрибут upvote на уровне класса остался.

# # Вот тут ниже можно раскомментить, если убрать строку с назначением upvote собственным методом.
# # first_comment.upvote(5)
# # print(first_comment.votes_qty)
# # Объект first_comment остался в памяти, мы дальше с ним работаем.
# # first_comment.upvote(10)
# # print(first_comment.votes_qty)

# first_comment.upvote(5)
# first_comment.upvote(10)
# print(first_comment.votes_qty)
# first_comment.reset_votes_qty()
# print(first_comment.votes_qty)

# # second_comment = Comment('Yo')
# # second_comment.upvote(2)
# # print(second_comment.votes_qty)
# # Проверили, что при назначении для объекта first_comment собственного метода upvote, этот метод добавился только к данному
# # объекту, но не к классу:
# # # print(second_comment.__dict__)


# 157. Практика - объекты с собственными аргументами (см. 156)


# 158. Задача - классы и экземпляры.
# 1. Создать класс Image
# 2. У каждого экземпляра класса Image должно быть 3 собственных атрибута
# resolution, title, extension (типа строка)
# 3. В классе должен быть метод resize, с помощью которого можно менять разрешение изображения.
# Нужно просто менять значение атрибута resolution.
# 4. Создать несколько экземпляров класса Image и вызвать метод resize.
# 5. Создать метод, который будет изменять title (вызывать заклавными буквами) и метод extension.
# class Image:
#     def __init__(self, resolution='1920x1280', title='my_summer', extension='.jpg'):
#         self.resolution = resolution
#         self.title = title
#         self.extension = extension

#     def resize(self, res):
#         self.resolution = res

#     def change_title(self, name):
#         self.title = name

#     def ext_change(self, ext):
#         self.extension = ext


# first_image = Image()
# print(first_image.resolution, first_image.title, first_image.extension)
# second_image = Image()
# second_image.resize('800x600')
# print(second_image.resolution)
# third_image = Image()
# third_image.change_title('autumn')
# print(third_image.title)
# forth_image = Image()
# forth_image.ext_change('.pdf')
# print(forth_image.extension)


# 159. Методы и экземпляры классов
# class Comment:
#     def __init__(self, text, initial_votes_qty=0):
#         self.text = text
#         self.votes_qty = initial_votes_qty

#     def upvote(self):
#         self.votes_qty += 1

#     def reset_votes_qty(self):
#         self.votes_qty = 0


# first_comment = Comment('Hello')
# # На уровне объекта upvote является привязанным методом. Если у метода первый параметр self - если он
# # ожидает объект (экземпляр определённого класса) в качестве первого параметра.
# print(first_comment.upvote)
# print(Comment.upvote)  # На уровне класса метод upvote функция
# # Comment.upvote()  # Ошибка. Привязанный метод нельзя вызывать как метод класса.
# first_comment.upvote()
# Comment.upvote(first_comment)


# 160. Статические методы классов
# Можно вызывать без привязки к экземпляру класса, на уровне класса.
# class Comment:
#     @staticmethod  # это есть декоратор
#     def merge_comments(first, second):
#         return f'{first} {second}'


# my_comment = Comment()
# # Статические методы доступны как атрибуты классов, так и атрибуты экземпляров класса.
# m_1 = Comment.merge_comments('Hello,', 'Nick')
# m_2 = my_comment.merge_comments('once', 'again')
# print(m_1, m_2)
# print(dir(Comment) == dir(my_comment))


# 161. Атрибуты класса.
# На уровне экземпляров класса можно обращаться к атрибутам класса, но изменить их нельзя.
# При изменении собственного атрибута экземпляра класса, это не имеет влияние на другие экземпляры класса.
# class Comment:
#     total_comments = 0  # Вот это именно атрибут класса

#     def __init__(self, text):  # А это собственные атрибуты экземпляра класса
#         self.text = text
#         self.votes_qty = 0
#         # Тут мы прибавляем каждый раз к атрибуту класса +1 при создании экземпляра класса
#         Comment.total_comments += 1


# first_comment = Comment('first_comment')
# print(Comment.total_comments)
# second_comment = Comment('second_comment')
# print(Comment.total_comments)
# # Атрибуты класса доступны на уровне экземпляров класса
# print(first_comment.total_comments)
# # так мы добавили собственный атрибут для объекта first_comment
# # first_comment.total_comments = 3
# print(first_comment.__dict__)
# # при этом значение атрибута для total_comments класса не изменилось.
# print(Comment.total_comments)
# print(first_comment.total_comments)
# # Но можно изменить значение атрибута класса, обратившись к нему через метод класса
# Comment.total_comments = 10
# print(Comment.total_comments)
# # Если есть значение собственного атрибута для экземпляра класса, то выведется сначала его значение.
# print(first_comment.total_comments)


# 162. Магические методы в собственных классах
# class Comment:
#     def __init__(self, text):
#         self.text = text
#         self.votes_qty = 0

#     def upvote(self):
#         self.votes_qty += 1

#     def __add__(self, other):
#         return (f'{self.text}, {other.text}', self.votes_qty + other.votes_qty)

#     def new_eq(self, other):
#         if self.text == other.text and self.votes_qty == other.votes_qty:
#             return True
#         else:
#             return False


# first_comment = Comment('Hello')
# first_comment.upvote()
# second_comment = Comment('Hello')
# second_comment.upvote()
# # Будет ошибка, потому что это наш класс и в нём нет метода .__add__
# print(first_comment + second_comment)
# # Так можно, т.к. класс Comment перенял атрибут .__eq__
# print(first_comment == second_comment)  # False, т.к. это 2 разных объекта
# # print(dir(first_comment))
# # True, т.к. значения одинаковы.
# print(Comment.new_eq(first_comment, second_comment))


# 163. Наследование из других классов
# # Метод __init__ родительского класса вызывается автоматически
# class ExtendedList(list):  # В скобках, потому что мы наследуем атрибуты класса list
#     def print_list_info(self):
#         print(f'List has {len(self)} elements')


# custom_list = ExtendedList([3, 5, 2])
# custom_list.print_list_info()
# # Получается цепочка классов. Класс ExtendedList подкласс класса list; list подкласс класса object.
# # Можно наследовать атрибуты нескольких классов одновременно.
# custom_list.append(9)
# custom_list.print_list_info()
# print(list.__subclasses__())

# 164. Практика - создание подклассов (см. выше)


# 165. Модули
# Модули позволяют избегать дублирования кода.
# Любой файл с расширением .py является модулем в пайтон.
# Из любого модуля можно импортировать функцию, или класс.
# Все переменные объявленные в модуле в глобальной зоне видимости, доступны в других модулях.
# Импорты следует располагать вверху файла.
# При импорте можно переименовать модуль import some as s
# Можно импортировать определённые переменные из модуля from module import some


# 166. Модули - практика
# import modules as modules
# from modules import *  # а можно и так всё импортировать

# print(modules)
# print(type(modules))
# print(dir(modules))
# print(modules.name)
# modules.print_sum(5, 4)

# from modules import print_sum as p, name as n

# p(6, 3)
# print(n)


# 167. Что такое __main__ и __name__
# from modules import myfn
# print('main.py', __name__)
# print('main.py', __name__ == '__main__')
# # Если мы выполняем принт метода __name__  из активного файла, он будет являться __main__.
# # Если мы выполняем импортированный модуль, он будет иметь __name__ с названием модуля.


# 168. Встроенные в пайтон модули
# help('calendar')  # Вот так можно посмотреть инфо по определённому модулю
# help('modules')  # Список всех доступных по-умолчанию модулей в пайтон


# 169. Создание пакетов
# # Пакет - это набор модулей. Можно сохранять локально или на сервер.
# # Просто создал папку и переместил в нее 2 модуля и добавил файл __init__.py
# # Вот так можно импортировать и получать доступ к содержимому:
# from pack.more_modules import my_name
# import pack.modules
# print(pack.modules.a)
# my_name('Nick')
# # Импортировать пакет нельзя, только модуль из пакета.


# 170. JSON (javascript object notation)
# Это формат обмена данными между компьютерами в интернете и формат файла. При обращении на удалённые сервера
# сервера отправляют формат именно в формате json
# очень похож на словари в пайтон, но где ключ используются двойные ""
# Допустимые типы значений в json: string, number, JSON object {}, boolean, array[] (массив), null.
# Данные в формате JSON передаются в виде строки.


# 171. Конвертация JSON в словарь
# import json
# # Вот это строка JSON
# json_str = '{"id": 235, "brand": "Nike", "qty": 84, "status": {"isForSale":"true"}}'
# print(type(json_str))
# sneakers = json.loads(json_str)
# print(type(sneakers))
# print(sneakers['id'])
# print(sneakers['brand'])
# print(sneakers['status']['isForSale'])

# Словарь можно конвертировать в JSON путем json.dumps()
# import json
# sneakers = {
#     'id': 235,
#     'brand': 'Nike',
#     'qty': 84,
#     'status': {
#         'isForSale': True
#     },
# }
# # Если добавить вторым аргументом indent=1, то json расставит как надо отступы, удобно читать, он не будет
# # на одной строке.
# json_string = json.dumps(sneakers, indent=1)
# print(json_string)
# print(type(json_string))

# Соотнесение типов python и json:
# str = String
# int, float = Number
# True = true
# False = false
# None = null
# dict = Object
# list, tuple = Array. Обратно массивы Array конвертируются только в списки пайтон.


# 172. Практика - JSON
# import json
# # часто с серверов приходят данные в виде массива объектов
# json_array = '[{"a": 1}, {"b": 2}]'
# my_list = json.loads(json_array)
# print(my_list)
# print(type(my_list))


# 173. Задача - JSON
# 1. Создать словарь со значениями разных типов
# 2. Конвертировать словарь в JSON
# 3. Результирующий JSON вывести в терминал
# 4. Вывести в терминал тип результирующего значения.
# import json
# my_dict = {
#     'name': 'Nick',
#     'age': 29,
#     'is_smart': True,
#     'height': 182.5,
#     'is_available': ['maybe', 'no']
# }
# dict_to_json = json.dumps(my_dict, indent=1)
# print(dict_to_json)
# print(type(dict_to_json))


# 174. Работа с файлами.
# # Встроенные модули: os - пакет, который содержит различные модули, в том числе path и pathlib - ООП к работе с
# # файлами, т.е. для каждого файла создаётся объект path, и мы уже работаем с этим объектом.
# # 1 способ = функциональный подход. Определение нахождения пути до  файла main.py через функции.
# from pathlib import Path
# from os import path
# print(path.abspath('.'))
# print(type(path))  # Экземпляр класса модуль.

# # 2 способ - pathlib. Это ООП подход. Т.е. импортируем класс Path и работаем с экземпляром класса
# print(Path('.').absolute())
# print(type(Path))


# 175. Методы класса Path
# from pathlib import Path
# # Если нету /перед файлом - это относительный путь, будет искать в текущей папке
# file_path = Path('modules.py')
# print(file_path)
# # Сокращённый цикл for in. Если элемент не начинается с _, то вывести список атрибутов модуля.
# # Т.е. нам не нужны магические методы.
# print([m for m in dir(file_path) if not m.startswith('_')])

# Найти абсолютный путь к текущей директории:
# from pathlib import Path
# print(Path.cwd())  # Current working directory

# Формирование путей на Windows
# from pathlib import Path
# print(Path('C:/').joinpath('Users').joinpath('Nick'))
# # Или вот так:
# print(Path('C:/') / 'Users' / 'Nick')

# Проверка присутствия директории или файла
# from pathlib import Path
# print(Path('main.py').exists())  # Это относительный путь
# print(Path('Users/Nick/Desctop').exists())  # Это абсолютный путь

# Проверка это директория или файл
# from pathlib import Path
# print(Path('main.py').is_file())
# print(Path('main.py').is_dir())
# # ../ означает выход на директорию выше. Просто '.' это текущая директория.
# # Если ../../ это выход на 2 директории выше.
# print(Path('../practise').is_dir())

# Посмотреть какие директории и файлы есть:
# from pathlib import Path
# for n in Path('.').iterdir():
#     print(n)


# 176. Практика - работа с путями к файлам и директориям.
# Функциональный подход
# from os import path
# print(path.curdir)  # относительный путь. Результат: "."
# print(path.abspath('.'))  # абсолютный путь к текущей директории

# ООП подход
# Если навести на модуль и нажать ctrl+левый клик, то откроется модуль pathlib
# from pathlib import Path
# cwd = Path('.')
# print(cwd)
# print(cwd.absolute())  # Вот абсолютный путь к текущей папке
# print(isinstance(cwd, Path))
# print(type(cwd))
# print(Path.__subclasses__())
# print(dir(cwd))
# cwd = Path('C:/').joinpath('Users/').joinpath('Nick').joinpath('some')
# cwd = Path('C:/') / 'D' / 'Важное' / 'Программирование' / \
#     'Practise' / 'Django'
# print(cwd)
# if not cwd.exists():
#     # Создать директорию в cwd. 2 раза нельзя, ошибка будет.
#     print(cwd.mkdir())
# print(cwd.exists())
# print(cwd.is_dir())
# if cwd.exists():
#     cwd.rmdir()  # Удалить директорию имеющуюся.


# 177. Чтение и запись файлов
# with open('text.txt') as test_file:  # пишем относительный путь, т.к. файл в рабочей директории
#     print(test_file.read())
# with open('text.txt') as test_file:
#     print(test_file.readlines())  # В виде списка строк

# А вот так перезаписываем содержимое файла
# with open('text.txt', 'w') as new_file:
#     new_file.write('First line in new file\n')
# with open('text.txt') as new_file:  # Перезаписали и читаем:
#     print(new_file.read())

# # А вот так добавить запись к существующим:
# with open('text.txt', 'a') as new_file:
#     new_file.write('Second line in new file\n')
# with open('text.txt') as new_file:  # Перезаписали и читаем:
#     print(new_file.read())


# Вот так можно удалять файлы, с помощью метода unlink объекта Path
# from pathlib import Path
# if Path('text.txt').exists() == True:
#     Path('text.txt').unlink()
# else:
#     pass
# print(Path('text.txt').exists())


# 178. Практика - запись и чтение файлов.
# test_file = open('text.txt', 'w')
# test_file.write('First line\n')
# test_file.close  # Надо закрыть, т.к. он открыт и не прочитается
# Две строки кода выше можно сделать вот без закрытия:
# with open('text.txt', 'w') as test_file:
#     test_file.write('First line\n')  # тут автоматическое закрытие.
# test_file = open('text.txt')  # И заново открыть.
# print(test_file.read())
# test_file.close
# Три строки выше равносильны этим:
# with open('text.txt') as test_file:
#     print(test_file.read())  # автоматически закроется.

# Перебор строк:
# with open('text.txt', 'w') as test_file:
#     test_file.write('First line\n')
#     test_file.write('Second line\n')
#     test_file.write('Third line\n')
# with open('text.txt') as test_file:
#     for line in test_file:
#         print(line)
# with open('text.txt') as test_file:
#     print(test_file.readline())  # по одной читать будет
#     print(test_file.readline())
# with open('text.txt') as test_file:
#     while True:
#         line = test_file.readline()
#         print(line)
#         if not line:
#             break


# 179. Практика - удаление файлов. (см. выше)


# 180. Задача - чтение и удаление файлов
# 1. Создать папку files в текущей папке
# 2. Добавить 2 файла first.txt и second.txt в эту папку и записать в них по 2-3 строки
# 3. Прочитать и вывести в терминал все строки 1го файла
# 4. Прочитать все строки второго файла одна за другой
# 5. Удалить оба файла
# 6. Удалить папку files.
# from pathlib import Path
# import os
# cwd = Path('C:/') / 'D' / 'Важное' / 'Программирование' / \
#     'Practise' / 'files'
# cwd = Path('./files')  # так проще
# if not cwd.exists():
#     cwd.mkdir()
# dir_file_one = r'C:\D\Важное\Программирование\Practise\files\first.txt'
# dir_file_one = Path('./files/first.txt')  # Так проще
# with open(dir_file_one, 'w') as first_file:
#     first_file.write('First line of first file\n')
#     first_file.write('Second line of first file\n')
#     first_file.write('Third line of first file\n')
# with open(dir_file_one) as first_file:
#     print(first_file.read())
# dir_file_two = r'C:\D\Важное\Программирование\Practise\files\second.txt'
# dir_file_two = Path('./files/second.txt')  # Так проще
# with open(dir_file_two, 'w') as second_file:
#     second_file.write('First line of second file\n')
#     second_file.write('Second line of second file\n')
#     second_file.write('Third line of second file\n')
# with open(dir_file_two) as second_file:
#     while True:
#         line = second_file.readline()
#         print(line.upper())
#         if not line:
#             break
# if Path(dir_file_one).exists() == True:
#     Path(dir_file_one).unlink()
# else:
#     pass
# print(Path(dir_file_one).exists())
# if Path(dir_file_two).exists() == True:
#     Path(dir_file_two).unlink()
# else:
#     pass
# print(Path(dir_file_two).exists())
# if cwd.exists():
#     os.rmdir(cwd)
#     print(cwd.exists())
# else:
#     pass


# 181. Создание и распаковка zip архивов
# from zipfile import ZipFile
# from pathlib import Path
# # print([m for m in dir(ZipFile) if not m.startswith('_')])
# if Path('my-files').exists() == False:
#     Path('my-files').mkdir()
# else:
#     pass
# with open('my-files/first.txt', 'w') as first_file:
#     first_file.write('This is the first file')
# with open('my-files/second.txt', 'w') as second_file:
#     second_file.write('This is the second file')
# with ZipFile('my-files.zip', mode='w') as my_zip_file:
#     # print(my_zip_file)
#     for file in Path('my-files').iterdir():
#         # print(file)
#         my_zip_file.write(file)  # Этим методом создаём архив
# with ZipFile('my-files.zip') as my_unzipped_file:
#     my_unzipped_file.extractall('my_files_unzipped')


# 182. см. выше

# 183. Работа с CSV файлами
# CSV это универсальный формат сохранения данных, которые разделяются определенными символами.
# import csv
# with open('test.csv', 'w') as csv_file:
#     writer = csv.writer(csv_file, delimiter=';')
#     writer.writerow(['user_id', 'user_name', 'comments_qty'])
#     writer.writerow([5613, 'Nick', 136])
#     writer.writerow([1374, 'Olya', 567])
#     writer.writerow([5573, 'Boris', 173])

# with open('test.csv') as csv_read:
#     reader = csv.reader(csv_read, delimiter=';')
#     print(reader)
#     print(type(reader))
#     for line in reader:
#         print(line)
#     print(reader.line_num)

# 184. Практика - чтение csv файлов (см. выше)


# 185. Модуль datetime
# from datetime import date
# from datetime import time
# from datetime import datetime
# # Класс type. Это значит, что это класс. Из него создаются экземпляры класса.
# print(type(date))
# my_date = date(2100, 4, 25)
# print(my_date)
# print(my_date.day)
# # Это именованный кортеж, в котором можно сохранять пары ключ-значение.
# print(my_date.isocalendar())
# my_time = time(13, 50, 16)
# print(my_time)
# print(my_time.hour)
# my_datetime = datetime(2023, 12, 24, 13, 52, 33)
# print(my_datetime)
# print(my_datetime.isoformat())
# print(my_datetime.now())


# 186. Практика - форматирование дат
# from datetime import datetime
# my_datetime = datetime(2023, 12, 24, 13, 52, 33)
# print(my_datetime.strftime('%d-%b-%Y %H-%M-%S'))
# print(my_datetime.strftime('%d/%m/%y'))
# date_str = '24/12/2023'
# converted_date = datetime.strptime(date_str, '%d/%m/%Y')
# print(converted_date)


# 187. Использование класса timedelta
# from datetime import datetime, timedelta
# my_datetime = datetime(2023, 12, 24, 13, 52, 33)
# # Прибавили 100 дней к дате и 120 минут ко времени.
# print(my_datetime + timedelta(days=100, minutes=120))
# print(my_datetime - timedelta(days=100, minutes=120))


# 188. Модуль time
# С его помощью можно останавливать выполнение кода или замерять, сколько времени заняла операция.
# import time
# # Это время с начала Unix этохи до сегодня в секундах (от 1.1.1970)
# print(time.time())
# print(time.ctime(1703416334))  # переформатируем в дату
# time.sleep(2.5)  # На 2.5 секунды останавливаем выполнение кода.
# print(time.time())

# Вот так можно посмотреть, сколько заняла операция:
# start_time = time.time()
# my_list = list(range(1000000))
# print(my_list[10000])
# end_time = time.time()
# print('Total operatons time is: ', end_time - start_time)


# 189. Модуль random
# Генерирует псевдослучайные значения (как-то привязывается к дате)
# import random
# print(random.random())  # Выводит случайное число от 0 до 1.
# print(random.randint(1, 10))  # Целое число в диапазоне включительно.
# print(random.choice('abcd'))  # случайное значение из последовательности
# print(random.choice([1, 4, 6, 7, 2]))  # случайное из списка
# print(random.choices([1, 4, 6, 7, 2], k=2))  # n элементов из списка
# # n элементов из списка. Пустая строка + объединить эти элементы.
# print(''.join(random.choices('0123456789', k=8)))

# my_list = [1, 65, 7, 3, 2, 5, 7]
# random.shuffle(my_list)  # Перемешать последовательность
# print(my_list)


# 190. Модуль secrets для генерации паролей
# import secrets
# import string
# print(string.ascii_letters)
# print(string.ascii_lowercase)
# print(string.ascii_uppercase)
# print(string.digits)
# print(string.punctuation)

# all_chars = string.ascii_letters + string.digits + string.punctuation
# # .choice выводит только 1 символ.
# # а вот так 8 символов.
# print(''.join(secrets.choice(all_chars) for i in range(8)))


# 191. Модуль math
# import math
# print(math.pi)
# print(math.e)
# print(math.sqrt(25))
# print(math.factorial(5))
# print([m for m in dir(math) if not m.startswith('_')])


# 192. Рекурсивная функция
# Это функция, которая внутри себя вызывает себя же.
# def calc_factorial(num):
#     if type(num) is not int:
#         raise TypeError('Digit must be integer')
#     elif num <= 0:
#         raise ValueError('Digit must be upper zero')
#     elif num == 1:
#         return 1
#     return calc_factorial(num - 1) * num


# print(calc_factorial(5))
# print(5*4*3*2*1)


# 193. Модуль для регулярных выражений re
# import re
# my_str = 'My name is Nick.'
# # точка в регулярном выражении обозначает символ.
# res = re.search('N..k', my_str)
# # начинается с M, далее любые символы и заканчивается на name
# res2 = re.search('^M.*name', my_str)
# # символ $ означает конец строки. Через \ мы ищем именно точку.
# res3 = re.search(r'N..k\.$', my_str)
# print(res)
# print(res2)
# print(res3)
# print(r'N..k\n.$')  # r строка пишет все на одной строке, не дает переносить.
# print(res.span())  # в каких элементах мы нашли искомое значение.
# print(res.start())  # также начало и конец.
# print(res.end())


# 194. Сохранение паттерна в отдельном объекте
# import re
# my_str = 'My name is Nick.'
# my_str2 = 'My name is Nick. Nook is smart'
# my_pattern = re.compile(r'N..k\.$')
# my_pat2 = re.compile(r'^My.*\.$')
# my_pat3 = re.compile(r'N..k')
# print(my_pattern)
# print(my_pattern.search(my_str))
# print(my_pat2.match(my_str))  # ищем совпадение.
# print(my_pat3.findall(my_str2))


# 195. Проверка email с помощью регулярного выражения.
# import re


# def check_email(mail):
#     reg_exp = r'[a-zA-Z0-9_.]+@[a-zA-Z0-9]+\.[a-zA-Z0-9-.]+$'
#     email_check_pattern = re.compile(reg_exp)
#     validation_result = 'valid' if email_check_pattern.fullmatch(
#         mail) else 'not valid'
#     return (mail, validation_result)


# # такой email прошел проверку регулярного выражения.
# print(check_email('bs@gmail.com'))
# # а это и все ниже не прошли.
# print(check_email('bsgmail.com'))
# print(check_email('bs@gmailcom'))
# print(check_email('@gmail.com'))
# print(check_email('bs@'))


# 196. Задача - проверка пароля.
# 1. Создать функцию для проверки пароля с помощью регулярного выражения.
# 2. Минимум 8 символов.
# 3. В пароле должны быть буквы в верхнем и нижнем регистре, цифры и спец. символы.
# 4. Попросить пользователя ввести пароль в терминале и проверить его с помощью нашей функции.
# 5. Можно также проверять и email.
# Вероятно, придется несколько проверок вводить через and чтобы проверить наличие п.3

# import re
# import string


# def check_pass(passw):
#     reg_exp = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$'
#     pass_check_pattern = re.compile(reg_exp)
#     validation_result = 'Your pass is valid' if pass_check_pattern.fullmatch(
#         passw) else 'Your pass is not valid'
#     return (validation_result)


# def check_email(mail):
#     reg_exp = r'[a-zA-Z0-9_.]+@[a-zA-Z0-9]+\.[a-zA-Z0-9-.]+$'
#     email_check_pattern = re.compile(reg_exp)
#     validation_result = 'Your email is valid' if email_check_pattern.fullmatch(
#         mail) else 'Your email is not valid'
#     return (validation_result)


# print(check_pass(input('Please enter your password: ')))
# print(check_email(input('Please enter your email: ')))
# # Z9fa%3Jd


# 197-200. Отправка email с помощью smtplib (не актуально)


# 201. Модуль SQLite3 и создание базы данных
# import sqlite3
# # с большой буквы, т.к. показываем, что не надо чтобы менялось.
# DB_NAME = 'sqlite_db.db'
# with sqlite3.connect(DB_NAME) as sqlite_con:
#     # print(sqlite_con)
#     # print(sqlite3.version)
#     sql_request = """CREATE TABLE IF NOT EXISTS courses (
#     id integer PRIMARY KEY,
#     title text NOT NULL,
#     students_qty integer,
#     reviews_qty integer
#     );"""
#     sqlite_con.execute(sql_request)
# # id и title обязательные поля.
# # Добавляем в базу данных курс по питону.
# # with sqlite3.connect(DB_NAME) as sqlite_con:
# #         sql_request = "INSERT INTO courses VALUES(?,?,?,?)"
# #         sqlite_con.execute(sql_request, (251, "Python courses", 100, 30))
# #         sqlite_con.commit()

# # Создаем список кортежей, чтобы их также добавить в базу данных
# # При этом первый запрос закомментирую, чтобы опять не добавлялся, т.к. будет ошибка.
# courses = [
#     (122, 'C++ course', 98, 23),
#     (51, "Java course", 70, 11),
#     (65, "Kotlin course", 86, 25)
# ]
# with sqlite3.connect(DB_NAME) as sqlite_con:
#     sql_request = "INSERT INTO courses VALUES(?,?,?,?)"
#     for course in courses:
#         sqlite_con.execute(sql_request, course)
#     sqlite_con.commit()

# 202. Практика - запись данных в базу sqlite3 (см. выше)


# 203. Практика - чтение данных из sqlite3.
# import sqlite3

# DB_NAME = 'sqlite_db.db'
# with sqlite3.connect(DB_NAME) as sqlite_con:
#     # звездочка это значит всё.
#     sql_request = "SELECT * FROM courses WHERE reviews_qty>=25"
#     sql_cursor = sqlite_con.execute(sql_request)
#     # for record in sql_cursor:
#     #     print(record[1])
#     # чтобы выполнить этот код, нужно закомментировать выше, т.к. метод execute возвращает курсор,
#     # и он после верхнего кода будет внизу и ничего не выведется.
#     courses = sql_cursor.fetchall()
#     print(courses)


# 204. Модуль array
# # Чтобы создавать однотипные структуры данных.
# from array import array
# my_int_array = array('i', [4, 5, 10, 5, 7])
# print(type(my_int_array))
# my_int_array.append(15)
# print(my_int_array)
# # my_int_array.append('abc')  # будет ошибка, т.к. мы изначально определили, что это int (i)
# print(my_int_array.count(5))
# print(len(my_int_array))
# for elem in my_int_array:
#     print(elem)
# print(my_int_array[3])
# # записываем массив в файл. wb - записать в бинарный файл
# with open('my_array.bin', 'wb') as my_array:
#     my_int_array.tofile(my_array)

# # читаем данные из массива:
# imported_array = array('i')
# with open('my_array.bin', 'rb') as my_array:
#     # хотим прочитать три элемента из массива.
#     imported_array.fromfile(my_array, 3)
#     print(imported_array)

# imported_array.reverse()
# print(imported_array)


# 205. Аргументы функции и модуль sys
# # Выполнять в терминале напрямую, не через coderunner
# import sys
# print(sys.argv)  # путь до нашего модуля main.py
# if len(sys.argv) < 3:  # Если так - будет ошибка если меньше 2х значений ввести помимо main.py
#     raise IOError('You must enter login and pass')

# # username = sys.argv[1]
# # password = sys.argv[2]
# # или можно использоваться функцией распаковки списка:
# filename, username, password = sys.argv
# print(username, password)

# Задача: 1. создать новый файл process_array.py. В этом файле мы будем ожидать аргумент от пользователя,
# который будет являться именем файла, из которого нужно создать массив.
# from pathlib import Path
# from array import array

# # if Path('process_array.py').exists():
# #     pass
# # else:
# with open('process_array.py', 'w') as my_file:
#     my_file.write(input('Enter array file name: '))

# my_int_array = array('i', [4, 5, 10, 5, 7])

# with open('my_array.bin', 'wb') as my_array:
#     my_int_array.tofile(my_array)

# imported_array = array('i')
# with open('my_array.bin', 'rb') as my_array:
#     imported_array.fromfile(my_array, 5)
#     print(imported_array)


# 206. Модуль webbrowser
# import webbrowser
# webbrowser.open('pypi.org')


# 207. Менеджер пакетов pip (package manager for python)
# В терминале pip --version чтобы проверить версию pip установленную вместе с пайтон.
# В терминале pip list, чтобы проверить список установленных внешних пакетов
# Версии. pip 23.2.1 значит major 23, minor 2, patch 1 (по убыванию крупности обновлений)
# import pygame
# pygame.init()
# pip uninstall pygame  # вот так можно удалить модуль.


# 208. Виртуальные среды и pipenv
# Нужна для того, чтобы другой разработчик, взяв наш код и среду разработки с файлами
# Pipfile и Pipfile.lock, смог использовать именно наши версии пакетов и продолжить работу,
# используя них, без загрузки последних версий пакетов.

# 209. Создание виртуальной среды.
# Создали папку в корневом каталоге .venv (точка значит, что она скрытая)
# И далее с помощью команды pipenv install requests создаем вирутальную среду. При этом пакет
# requests не был создан глобально в pip list его нет, а есть в виртуальной среде.


# 210. Файлы Pipfile и Pipfile.lock
